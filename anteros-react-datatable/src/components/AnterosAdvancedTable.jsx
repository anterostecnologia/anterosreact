//https://github.com/glideapps/glide-data-grid
import * as React from "react";
import { createPortal } from "react-dom";
import { clamp } from "lodash/fp";
import copy from "copy-to-clipboard";
import baseStyled, { ThemeProvider, useTheme, css } from "styled-components";
import { SearchWrapper } from "./AnterosAdvancedTableStyle.jsx";
import { Carousel } from "react-responsive-carousel";
import { withDefault } from "collection-utils";
import marked from "marked";


const headerRowID = (props) => {
    const fg = withDefault(props.fgColor, "white");
    const bg = withDefault(props.bgColor, "currentColor");

    return `
        <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
            <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}" />
            <g clipPath="url(#clip0)">
                <path
                    d="M15.75 4H14.25C14.1835 4 14.12 4.0265 14.073 4.0735L9.30798 8.839C7.42398 7.9785 5.19948 8.8085 4.33898 10.6925C3.47848 12.5765 4.30848 14.801 6.19248 15.6615C8.07648 16.522 10.301 15.692 11.1615 13.808C11.6135 12.8185 11.6135 11.682 11.1615 10.6925L12.3175 9.536L13.284 9.858C13.5465 9.944 13.829 9.801 13.915 9.5385C13.9395 9.464 13.946 9.3855 13.934 9.308L13.7535 8.1L14.1165 7.737L14.8445 8.068C15.0955 8.1825 15.3925 8.072 15.507 7.8205C15.556 7.713 15.5655 7.5915 15.5335 7.478L15.2805 6.5735L15.927 5.927C15.974 5.88 16 5.8165 16 5.75V4.25C16 4.112 15.888 4 15.75 4ZM7.49998 13.25C7.49998 13.664 7.16398 14 6.74998 14C6.33598 14 5.99998 13.664 5.99998 13.25C5.99998 12.836 6.33598 12.5 6.74998 12.5C7.16398 12.5 7.49998 12.836 7.49998 13.25Z"
                    fill="${fg}"
                />
            </g>
            <defs>
                <clipPath id="clip0">
                    <rect x="4" y="4" width="12" height="12" fill="${fg}" />
                </clipPath>
            </defs>
        </svg>
    `;
};

const headerNumber = (props) => {
    const fg = withDefault(props.fgColor, "white");
    const bg = withDefault(props.bgColor, "currentColor");
    return `
        <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path
                d="M16.2222 2H3.77778C2.8 2 2 2.8 2 3.77778V16.2222C2 17.2 2.8 18 3.77778 18H16.2222C17.2 18 17.9911 17.2 17.9911 16.2222L18 3.77778C18 2.8 17.2 2 16.2222 2Z"
                fill="${bg}"
            />
            <path
                d="M6.52213 12.7778H5.50578V8.73768L4.17476 9.21511V8.33982L6.46787 7.51155H6.52213V12.7778Z"
                fill="${fg}"
            />
            <path
                d="M11.7289 12.7778H8.13729V12.0905L9.84085 10.2604C9.97347 10.1157 10.0856 9.9843 10.1772 9.86615C10.2688 9.748 10.3424 9.64069 10.3978 9.54424C10.4557 9.44538 10.4967 9.35375 10.5208 9.26936C10.5473 9.18497 10.5606 9.10298 10.5606 9.02341C10.5606 8.90526 10.5437 8.80037 10.51 8.70874C10.4762 8.61711 10.428 8.53995 10.3653 8.47726C10.305 8.41215 10.2315 8.36272 10.1447 8.32897C10.0603 8.29521 9.96623 8.27833 9.86255 8.27833C9.58525 8.27833 9.37788 8.35549 9.24044 8.50981C9.10541 8.66413 9.0379 8.87994 9.0379 9.15724H8.02878C8.02878 8.92334 8.07339 8.70271 8.16261 8.49534C8.25182 8.28556 8.37721 8.10231 8.53876 7.94557C8.70273 7.78884 8.89925 7.66587 9.12832 7.57665C9.3598 7.48502 9.61539 7.43921 9.8951 7.43921C10.1628 7.43921 10.3991 7.47658 10.604 7.55133C10.8114 7.62608 10.9838 7.73097 11.1212 7.866C11.2611 8.00103 11.3672 8.16379 11.4395 8.35428C11.5119 8.54236 11.548 8.75094 11.548 8.98001C11.548 9.15362 11.5203 9.32 11.4648 9.47914C11.4118 9.63587 11.3346 9.7914 11.2334 9.94572C11.1345 10.1 11.0151 10.258 10.8753 10.4195C10.7354 10.5787 10.5799 10.7463 10.4087 10.9223L9.41767 11.9712H11.7289V12.7778Z"
                fill="${fg}"
            />
            <path
                d="M13.5249 9.70339H14.071C14.3459 9.70339 14.5497 9.63467 14.6823 9.49722C14.8149 9.35737 14.8812 9.17532 14.8812 8.95107C14.8812 8.84739 14.8655 8.75335 14.8342 8.66895C14.8053 8.58215 14.7606 8.50861 14.7004 8.44832C14.6401 8.38563 14.5629 8.33741 14.4689 8.30365C14.3773 8.26989 14.27 8.25301 14.147 8.25301C14.0457 8.25301 13.9505 8.26748 13.8612 8.29641C13.7744 8.32535 13.6973 8.36755 13.6298 8.42301C13.5647 8.47605 13.5128 8.54116 13.4742 8.61832C13.4357 8.69548 13.4164 8.78228 13.4164 8.87873H12.4109C12.4109 8.66413 12.4543 8.46882 12.5411 8.2928C12.6303 8.11677 12.7521 7.96607 12.9064 7.84068C13.0607 7.71289 13.2416 7.61403 13.4489 7.5441C13.6587 7.47417 13.8842 7.43921 14.1253 7.43921C14.3857 7.43921 14.6244 7.47176 14.8414 7.53687C15.0584 7.59956 15.2441 7.6948 15.3984 7.8226C15.5527 7.94799 15.6721 8.10472 15.7565 8.2928C15.8433 8.47846 15.8867 8.69427 15.8867 8.94022C15.8867 9.05355 15.8698 9.16568 15.8361 9.27659C15.8023 9.3851 15.7529 9.48878 15.6878 9.58765C15.6227 9.68651 15.5419 9.77814 15.4454 9.86253C15.349 9.94451 15.2381 10.0156 15.1127 10.0759C15.2598 10.129 15.3864 10.1965 15.4925 10.2785C15.601 10.3605 15.6902 10.4545 15.7601 10.5606C15.83 10.6643 15.8819 10.7788 15.9156 10.9042C15.9494 11.0296 15.9663 11.1622 15.9663 11.3021C15.9663 11.548 15.9193 11.7674 15.8252 11.9603C15.7312 12.1532 15.6022 12.316 15.4382 12.4486C15.2742 12.5788 15.0789 12.6789 14.8523 12.7488C14.628 12.8163 14.3857 12.8501 14.1253 12.8501C13.901 12.8501 13.6816 12.8199 13.467 12.7597C13.2548 12.697 13.0655 12.6041 12.8992 12.4812C12.7328 12.3558 12.5989 12.199 12.4977 12.011C12.3988 11.8229 12.3494 11.6011 12.3494 11.3455H13.3549C13.3549 11.4467 13.3742 11.5408 13.4128 11.6276C13.4513 11.712 13.5056 11.7855 13.5755 11.8482C13.6479 11.9085 13.7322 11.9567 13.8287 11.9929C13.9251 12.0266 14.0312 12.0435 14.147 12.0435C14.4026 12.0435 14.6027 11.976 14.7474 11.841C14.8921 11.7059 14.9644 11.5227 14.9644 11.2912C14.9644 11.1489 14.9439 11.0272 14.9029 10.9259C14.8619 10.8246 14.8016 10.7414 14.7221 10.6763C14.6449 10.6112 14.5509 10.563 14.44 10.5317C14.3314 10.5003 14.2085 10.4846 14.071 10.4846H13.5249V9.70339Z"
                fill="${fg}"
            />
        </svg>
    `;
};

const headerString = (props) => {
    const fg = withDefault(props.fgColor, "white");
    const bg = withDefault(props.bgColor, "currentColor");
    return `
        <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path
                d="M16.2222 2H3.77778C2.8 2 2 2.8 2 3.77778V16.2222C2 17.2 2.8 18 3.77778 18H16.2222C17.2 18 17.9911 17.2 17.9911 16.2222L18 3.77778C18 2.8 17.2 2 16.2222 2Z"
                fill="${bg}"
            />
            <path
                d="M8.18183 12.4001H11.8182L12.4727 14.0001H14L10.5455 6.00006H9.45456L6.00002 14.0001H7.52729L8.18183 12.4001ZM10 7.44006L11.36 11.091H8.64002L10 7.44006Z"
                fill="${fg}"
            />
        </svg>
    `;
};

const headerBoolean = (props) => {
    const fg = withDefault(props.fgColor, "white");
    const bg = withDefault(props.bgColor, "currentColor");
    return `
        <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path
                d="M16.2222 2H3.77778C2.8 2 2 2.8 2 3.77778V16.2222C2 17.2 2.8 18 3.77778 18H16.2222C17.2 18 17.9911 17.2 17.9911 16.2222L18 3.77778C18 2.8 17.2 2 16.2222 2Z"
                fill="${bg}"
            />
            <path
                fill-rule="evenodd"
                clip-rule="evenodd"
                d="M7.66667 6.66669C5.73368 6.66669 4.16667 8.15907 4.16667 10C4.16667 11.841 5.73368 13.3334 7.66667 13.3334H12.3333C14.2663 13.3334 15.8333 11.841 15.8333 10C15.8333 8.15907 14.2663 6.66669 12.3333 6.66669H7.66667ZM12.5 12.5C13.8807 12.5 15 11.3807 15 10C15 8.61931 13.8807 7.50002 12.5 7.50002C11.1193 7.50002 10 8.61931 10 10C10 11.3807 11.1193 12.5 12.5 12.5Z"
                fill="${fg}"
            />
        </svg>
    `;
};

const headerAudioUri = (props) => {
    const fg = withDefault(props.fgColor, "white");
    const bg = withDefault(props.bgColor, "currentColor");
    return `
        <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path
                d="M16.2222 2H3.77778C2.8 2 2 2.8 2 3.77778V16.2222C2 17.2 2.8 18 3.77778 18H16.2222C17.2 18 17.9911 17.2 17.9911 16.2222L18 3.77778C18 2.8 17.2 2 16.2222 2Z"
                fill="${bg}"
            />
            <path
                fill-rule="evenodd"
                clip-rule="evenodd"
                d="M7 13.1384C7 13.5223 7.41474 13.763 7.74807 13.5725L13.2403 10.4341C13.5762 10.2422 13.5762 9.75783 13.2403 9.56588L7.74807 6.42747C7.41474 6.23699 7 6.47768 7 6.86159V13.1384Z"
                fill="${fg}"
            />
        </svg>
    `;
};

const headerVideoUri = (props) => {
    const fg = withDefault(props.fgColor, "white");
    const bg = withDefault(props.bgColor, "currentColor");
    return `
        <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path
                d="M16.2222 2H3.77778C2.8 2 2 2.8 2 3.77778V16.2222C2 17.2 2.8 18 3.77778 18H16.2222C17.2 18 17.9911 17.2 17.9911 16.2222L18 3.77778C18 2.8 17.2 2 16.2222 2Z"
                fill="${bg}"
            />
            <path
                fill-rule="evenodd"
                clip-rule="evenodd"
                d="M7 13.1384C7 13.5223 7.41474 13.763 7.74807 13.5725L13.2403 10.4341C13.5762 10.2422 13.5762 9.75783 13.2403 9.56588L7.74807 6.42747C7.41474 6.23699 7 6.47768 7 6.86159V13.1384Z"
                fill="${fg}"
            />
        </svg>
    `;
};

const headerEmoji = (props) => {
    const fg = withDefault(props.fgColor, "white");
    const bg = withDefault(props.bgColor, "currentColor");
    return `
        <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path
                d="M10 5C7.23875 5 5 7.23875 5 10C5 12.7612 7.23875 15 10 15C12.7612 15 15 12.7612 15 10C15 7.23875 12.7612 5 10 5ZM10 14.1667C7.7025 14.1667 5.83333 12.2975 5.83333 10C5.83333 7.7025 7.7025 5.83333 10 5.83333C12.2975 5.83333 14.1667 7.7025 14.1667 10C14.1667 12.2975 12.2975 14.1667 10 14.1667Z"
                fill="${fg}"
            />
            <path
                d="M8.3333 8.21451C8.03121 8.20768 7.74909 8.36491 7.596 8.62541C7.44291 8.88592 7.44283 9.2089 7.59579 9.46948C7.74875 9.73007 8.03079 9.88744 8.33288 9.88076C8.78575 9.87074 9.14768 9.50081 9.14779 9.04784C9.1479 8.59486 8.78616 8.22475 8.3333 8.21451ZM11.6666 8.21451C11.3645 8.20768 11.0824 8.36491 10.9293 8.62541C10.7762 8.88592 10.7762 9.2089 10.9291 9.46948C11.0821 9.73007 11.3641 9.88744 11.6662 9.88076C12.1191 9.87074 12.481 9.50081 12.4811 9.04784C12.4812 8.59486 12.1195 8.22475 11.6666 8.21451Z"
                fill="${fg}"
            />
            <path
                fill-rule="evenodd"
                clip-rule="evenodd"
                d="M14.5262 13.9059C13.4853 15.9876 10.5147 15.9876 9.47382 13.9059L10.2405 13.5226C10.9654 14.9725 13.0346 14.9725 13.7595 13.5226L14.5262 13.9059Z"
                fill="${fg}"
            />
            <path
                d="M16.2222 2H3.77778C2.8 2 2 2.8 2 3.77778V16.2222C2 17.2 2.8 18 3.77778 18H16.2222C17.2 18 17.9911 17.2 17.9911 16.2222L18 3.77778C18 2.8 17.2 2 16.2222 2Z"
                fill="${bg}"
            />
            <path
                d="M10 4C6.6865 4 4 6.6865 4 10C4 13.3135 6.6865 16 10 16C13.3135 16 16 13.3135 16 10C16 6.6865 13.3135 4 10 4ZM10 15C7.243 15 5 12.757 5 10C5 7.243 7.243 5 10 5C12.757 5 15 7.243 15 10C15 12.757 12.757 15 10 15Z"
                fill="${fg}"
            />
            <path
                d="M7.99995 7.85737C7.63744 7.84918 7.2989 8.03785 7.11519 8.35046C6.93148 8.66307 6.93138 9.05064 7.11494 9.36334C7.29849 9.67605 7.63694 9.86489 7.99945 9.85687C8.54289 9.84486 8.9772 9.40094 8.97734 8.85737C8.97748 8.31379 8.54338 7.86966 7.99995 7.85737ZM11.9999 7.85737C11.6374 7.84918 11.2989 8.03785 11.1152 8.35046C10.9315 8.66307 10.9314 9.05064 11.1149 9.36334C11.2985 9.67605 11.6369 9.86489 11.9994 9.85687C12.5429 9.84486 12.9772 9.40094 12.9773 8.85737C12.9775 8.31379 12.5434 7.86966 11.9999 7.85737Z"
                fill="${fg}"
            />
            <path
                fill-rule="evenodd"
                clip-rule="evenodd"
                d="M12.5262 11.9059C11.4853 13.9876 8.51466 13.9876 7.47382 11.9059L8.24047 11.5226C8.96543 12.9725 11.0346 12.9725 11.7595 11.5226L12.5262 11.9059Z"
                fill="${fg}"
            />
        </svg>
    `;
};

const headerImage = (props) => {
    const fg = withDefault(props.fgColor, "white");
    const bg = withDefault(props.bgColor, "currentColor");
    return `
        <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path
                d="M16.2222 2H3.77778C2.8 2 2 2.8 2 3.77778V16.2222C2 17.2 2.8 18 3.77778 18H16.2222C17.2 18 17.9911 17.2 17.9911 16.2222L18 3.77778C18 2.8 17.2 2 16.2222 2Z"
                fill="${bg}"
            />
            <path
                opacity="0.5"
                fill-rule="evenodd"
                clip-rule="evenodd"
                d="M12.499 10.8014C12.6965 10.5012 13.1367 10.5012 13.3343 10.8014L16.0317 14.8993C16.2506 15.2318 16.0121 15.6743 15.6141 15.6743H10.2191C9.82111 15.6743 9.58265 15.2318 9.8015 14.8993L12.499 10.8014Z"
                fill="${fg}"
            />
            <path
                fill-rule="evenodd"
                clip-rule="evenodd"
                d="M8.06928 8.93355C8.26787 8.64355 8.6958 8.64355 8.89438 8.93355L12.9743 14.8917C13.2015 15.2236 12.9639 15.6742 12.5617 15.6742H4.40192C3.99976 15.6742 3.76215 15.2236 3.98937 14.8917L8.06928 8.93355Z"
                fill="${fg}"
            />
            <path
                fill-rule="evenodd"
                clip-rule="evenodd"
                d="M13.75 8.33335C14.9006 8.33335 15.8333 7.40061 15.8333 6.25002C15.8333 5.09943 14.9006 4.16669 13.75 4.16669C12.5994 4.16669 11.6667 5.09943 11.6667 6.25002C11.6667 7.40061 12.5994 8.33335 13.75 8.33335Z"
                fill="${fg}"
            />
        </svg>
    `;
};

const headerUri = (props) => {
    const fg = withDefault(props.fgColor, "white");
    const bg = withDefault(props.bgColor, "currentColor");
    return `
        <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path
                d="M16.2222 2H3.77778C2.8 2 2 2.8 2 3.77778V16.2222C2 17.2 2.8 18 3.77778 18H16.2222C17.2 18 17.9911 17.2 17.9911 16.2222L18 3.77778C18 2.8 17.2 2 16.2222 2Z"
                fill="${bg}"
            />
            <path
                fill-rule="evenodd"
                clip-rule="evenodd"
                d="M10.2893 4.94676C11.6115 3.6686 13.7132 3.68688 15.013 4.98785C16.3128 6.28881 16.3311 8.3924 15.0541 9.71578L15.0454 9.72458L13.4493 11.3221C12.7581 12.0142 11.8007 12.3717 10.8254 12.3017C9.85023 12.2318 8.95344 11.7414 8.36781 10.9578C8.13313 10.6438 8.19722 10.1988 8.51096 9.96395C8.8247 9.72907 9.26928 9.79321 9.50396 10.1072C9.843 10.5609 10.3622 10.8448 10.9268 10.8853C11.4914 10.9258 12.0457 10.7188 12.4459 10.3181L12.446 10.318L14.0375 8.72513C14.7728 7.95872 14.761 6.74385 14.0098 5.992C13.2584 5.23993 12.0441 5.22826 11.2784 5.96492L10.3672 6.87166C10.0893 7.14814 9.64013 7.14683 9.3639 6.86873C9.08766 6.59063 9.08897 6.14106 9.36682 5.86458L10.282 4.95395L10.2893 4.94676Z"
                fill="${fg}"
            />
            <path
                fill-rule="evenodd"
                clip-rule="evenodd"
                d="M6.55073 8.67789C7.24194 7.98587 8.19937 7.62842 9.17454 7.69832C10.1498 7.76823 11.0466 8.25863 11.6322 9.04224C11.8669 9.35626 11.8028 9.80123 11.489 10.0361C11.1753 10.271 10.7307 10.2069 10.496 9.89284C10.157 9.43917 9.63778 9.15526 9.07319 9.11479C8.50859 9.07431 7.95427 9.28128 7.55409 9.68196L5.9625 11.275C5.22716 12.0414 5.23904 13.2562 5.99022 14.0081C6.7414 14.7599 7.95518 14.7718 8.72091 14.0358L9.62604 13.1299C9.90309 12.8526 10.3523 12.8526 10.6293 13.1299C10.9064 13.4072 10.9064 13.8567 10.6293 14.134L9.71948 15.0447L9.71069 15.0533C8.38848 16.3315 6.28677 16.3132 4.98695 15.0122C3.68714 13.7113 3.66888 11.6077 4.94591 10.2843L4.95455 10.2755L6.55073 8.67789Z"
                fill="${fg}"
            />
        </svg>
    `;
};

const headerPhone = (props) => {
    const fg = withDefault(props.fgColor, "white");
    const bg = withDefault(props.bgColor, "currentColor");
    return `
        <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
            <rect x="3" y="3" width="14" height="14" fill="${fg}" />
            <path
                d="M16.2222 2H3.77778C2.8 2 2 2.8 2 3.77778V16.2222C2 17.2 2.8 18 3.77778 18H16.2222C17.2 18 17.9911 17.2 17.9911 16.2222L18 3.77778C18 2.8 17.2 2 16.2222 2ZM8.97778 11.7778H10.2133C10.3556 11.7778 10.48 11.84 10.5689 11.9556L11.5467 13.2444C11.68 13.4222 11.6622 13.6711 11.5022 13.8222L10.2933 15.0311C10.1333 15.1911 9.86667 15.2089 9.69778 15.0667C8.69333 14.2133 7.94667 13.0667 7.58222 11.7689C7.42222 11.2089 7.33333 10.6133 7.33333 10C7.33333 9.38667 7.42222 8.79111 7.58222 8.22222C7.94667 6.91556 8.69333 5.77778 9.69778 4.92444C9.87556 4.77333 10.1333 4.8 10.2933 4.96L11.5022 6.16889C11.6622 6.32889 11.68 6.57778 11.5467 6.74667L10.5689 8.03556C10.4889 8.15111 10.3556 8.21333 10.2133 8.21333H8.97778C8.78222 8.77333 8.66667 9.36889 8.66667 9.99111C8.66667 10.6133 8.78222 11.2178 8.97778 11.7778Z"
                fill="${bg}"
            />
        </svg>
    `;
};

const headerMarkdown = (props) => {
    const fg = withDefault(props.fgColor, "white");
    const bg = withDefault(props.bgColor, "currentColor");
    return `
        <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path
                d="M16.2222 2H3.77778C2.8 2 2 2.8 2 3.77778V16.2222C2 17.2 2.8 18 3.77778 18H16.2222C17.2 18 17.9911 17.2 17.9911 16.2222L18 3.77778C18 2.8 17.2 2 16.2222 2Z"
                fill="${bg}"
            />
            <path
                d="M13.4867 13.148L11.1667 9.88313H12.5667V7H14.4333V9.88313H15.8333L13.4867 13.148Z"
                fill="${fg}"
                fillOpacity="0.5"
            />
            <path
                d="M11 12.998L9 13V10.001L7.5 11.9234L6 10.001V13H4V7.00195H6L7.5 9.0013L9 7.00195L11 7V12.998Z"
                fill="${fg}"
            />
        </svg>
    `;
};

const headerDate = (props) => {
    const fg = withDefault(props.fgColor, "white");
    const bg = withDefault(props.bgColor, "currentColor");
    return `
        <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path
                d="M16.2222 2H3.77778C2.8 2 2 2.8 2 3.77778V16.2222C2 17.2 2.8 18 3.77778 18H16.2222C17.2 18 17.9911 17.2 17.9911 16.2222L18 3.77778C18 2.8 17.2 2 16.2222 2Z"
                fill="${bg}"
            />
            <path
                d="M14.8 4.18182H14.2V3H13V4.18182H7V3H5.8V4.18182H5.2C4.54 4.18182 4 4.71364 4 5.36364V14.8182C4 15.4682 4.54 16 5.2 16H14.8C15.46 16 16 15.4682 16 14.8182V5.36364C16 4.71364 15.46 4.18182 14.8 4.18182ZM14.8 14.8182H5.2V7.13636H14.8V14.8182Z"
                fill="${fg}"
            />
        </svg>
    `;
};

const headerTime = (props) => {
    const fg = withDefault(props.fgColor, "white");
    const bg = withDefault(props.bgColor, "currentColor");
    return `
        <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path
                d="M16.2222 2H3.77778C2.8 2 2 2.8 2 3.77778V16.2222C2 17.2 2.8 18 3.77778 18H16.2222C17.2 18 17.9911 17.2 17.9911 16.2222L18 3.77778C18 2.8 17.2 2 16.2222 2Z"
                fill="${bg}"
            />
            <path
                d="M9.994 4C6.682 4 4 6.688 4 10C4 13.312 6.682 16 9.994 16C13.312 16 16 13.312 16 10C16 6.688 13.312 4 9.994 4ZM10 14.8C7.348 14.8 5.2 12.652 5.2 10C5.2 7.348 7.348 5.2 10 5.2C12.652 5.2 14.8 7.348 14.8 10C14.8 12.652 12.652 14.8 10 14.8Z"
                fill="${fg}"
            />
            <path d="M10 7H9V10.9344L12.5 13L13 12.1934L10 10.4426V7Z" fill="${fg}" />
        </svg>
    `;
};

const headerEmail = (props) => {
    const fg = withDefault(props.fgColor, "white");
    const bg = withDefault(props.bgColor, "currentColor");
    return `
        <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
            <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}" />
            <path
                fill-rule="evenodd"
                clip-rule="evenodd"
                d="M10 8.64286C9.25047 8.64286 8.64286 9.25047 8.64286 10C8.64286 10.7495 9.25047 11.3571 10 11.3571C10.7495 11.3571 11.3571 10.7495 11.3571 10C11.3571 9.25047 10.7495 8.64286 10 8.64286ZM7.35715 10C7.35715 8.54039 8.54039 7.35715 10 7.35715C11.4596 7.35715 12.6429 8.54039 12.6429 10C12.6429 11.4596 11.4596 12.6429 10 12.6429C8.54039 12.6429 7.35715 11.4596 7.35715 10Z"
                fill="${fg}"
            />
            <path
                fill-rule="evenodd"
                clip-rule="evenodd"
                d="M7.589 4.89846C8.74047 4.3543 10.0422 4.21568 11.2824 4.50511C12.5227 4.79455 13.6285 5.49503 14.4202 6.49266C15.2119 7.49029 15.6428 8.72638 15.6429 9.99996V10.5C15.6429 11.0683 15.4171 11.6134 15.0152 12.0152C14.6134 12.4171 14.0683 12.6429 13.5 12.6429C12.9317 12.6429 12.3866 12.4171 11.9848 12.0152C11.5829 11.6134 11.3571 11.0683 11.3571 10.5V8C11.3571 7.64496 11.645 7.35714 12 7.35714C12.355 7.35714 12.6429 7.64496 12.6429 8V10.5C12.6429 10.7273 12.7332 10.9453 12.8939 11.1061C13.0546 11.2668 13.2727 11.3571 13.5 11.3571C13.7273 11.3571 13.9453 11.2668 14.1061 11.1061C14.2668 10.9453 14.3571 10.7273 14.3571 10.5V10C14.3571 10 14.3571 10.0001 14.3571 10C14.3571 9.01666 14.0243 8.06218 13.4131 7.29187C12.8018 6.52155 11.9479 5.98067 10.9902 5.75718C10.0326 5.53369 9.02745 5.64074 8.13834 6.06091C7.24923 6.48108 6.5284 7.18966 6.09306 8.07145C5.65772 8.95323 5.53347 9.95635 5.74052 10.9177C5.94758 11.8791 6.47375 12.7421 7.23348 13.3665C7.99322 13.9909 8.94183 14.3399 9.92508 14.3568C10.9083 14.3737 11.8684 14.0575 12.6491 13.4596C12.931 13.2437 13.3345 13.2973 13.5504 13.5791C13.7662 13.861 13.7127 14.2645 13.4309 14.4804C12.4197 15.2547 11.1764 15.6642 9.90298 15.6423C8.62959 15.6204 7.40105 15.1684 6.41714 14.3598C5.43322 13.5511 4.75178 12.4334 4.48363 11.1884C4.21548 9.94338 4.37639 8.64426 4.94019 7.50227C5.50399 6.36029 6.43752 5.44261 7.589 4.89846Z"
                fill="${fg}"
            />
        </svg>
    `;
};

const headerReference = (props) => {
    const fg = withDefault(props.fgColor, "white");
    const bg = withDefault(props.bgColor, "currentColor");
    return `
        <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
            <rect x="2" y="8" width="10" height="8" rx="2" fill="${bg}" />
            <rect x="8" y="4" width="10" height="8" rx="2" fill="${bg}" fillOpacity="0.5" />
            <path
                d="M10.6759 7.7265V6L13.6515 9.02137L10.6759 12.0427V10.2731C8.55051 10.2731 7.06271 10.9637 6 12.4744C6.42509 10.3162 7.70034 8.15812 10.6759 7.7265Z"
                fill="${fg}"
            />
        </svg>
    `;
};

const headerIfThenElse = (props) => {
    const fg = withDefault(props.fgColor, "white");
    const bg = withDefault(props.bgColor, "currentColor");
    return `
        <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
            <rect x="4" y="3" width="12" height="14" fill="${fg}" />
            <path
                fill-rule="evenodd"
                clip-rule="evenodd"
                d="M3.6 2C3.17565 2 2.76869 2.16857 2.46863 2.46863C2.16857 2.76869 2 3.17565 2 3.6V16.4C2 16.8243 2.16857 17.2313 2.46863 17.5314C2.76869 17.8314 3.17565 18 3.6 18H16.4C16.8243 18 17.2313 17.8314 17.5314 17.5314C17.8314 17.2313 18 16.8243 18 16.4V3.6C18 3.17565 17.8314 2.76869 17.5314 2.46863C17.2313 2.16857 16.8243 2 16.4 2H3.6ZM14.9 12.8C15.2864 12.8 15.6 13.1136 15.6 13.5V14.9C15.6 15.0857 15.5263 15.2637 15.395 15.395C15.2637 15.5263 15.0857 15.6 14.9 15.6H13.5C13.3143 15.6 13.1363 15.5263 13.005 15.395C12.8738 15.2637 12.8 15.0857 12.8 14.9V13.5C12.8 13.152 13.056 12.8568 13.4 12.8072C13.4277 12.8032 13.453 12.7893 13.4714 12.7682C13.4898 12.747 13.4999 12.72 13.5 12.692V10.3496C13.4998 10.3188 13.4874 10.2893 13.4655 10.2675C13.4436 10.2458 13.414 10.2336 13.3832 10.2336H10.5832C10.5522 10.2336 10.5225 10.2459 10.5006 10.2678C10.4787 10.2897 10.4664 10.3194 10.4664 10.3504V12.6832C10.4664 12.7472 10.5192 12.8 10.5832 12.8H10.7C11.0864 12.8 11.4 13.1136 11.4 13.5V14.9C11.4 15.0857 11.3263 15.2637 11.195 15.395C11.0637 15.5263 10.8857 15.6 10.7 15.6H9.3C9.11435 15.6 8.9363 15.5263 8.80503 15.395C8.67375 15.2637 8.6 15.0857 8.6 14.9V13.5C8.6 13.1128 8.9136 12.7992 9.3 12.7992H9.4168C9.4808 12.7992 9.5336 12.7472 9.5336 12.6832V10.3496C9.5336 10.3186 9.5213 10.2889 9.49939 10.267C9.47749 10.2451 9.44778 10.2328 9.4168 10.2328H6.6168C6.58582 10.2328 6.55611 10.2451 6.53421 10.267C6.51231 10.2889 6.5 10.3186 6.5 10.3496V12.692C6.5 12.7496 6.5424 12.7984 6.6 12.8072C6.944 12.8568 7.2 13.1512 7.2 13.5V14.9C7.2 15.0857 7.12625 15.2637 6.99497 15.395C6.8637 15.5263 6.68565 15.6 6.5 15.6H5.1C5.00807 15.6 4.91705 15.5819 4.83212 15.5467C4.74719 15.5115 4.67003 15.46 4.60503 15.395C4.54002 15.33 4.48846 15.2528 4.45328 15.1679C4.41811 15.083 4.4 14.9919 4.4 14.9V13.5C4.4 13.1136 4.7136 12.8 5.1 12.8H5.4504C5.5144 12.8 5.5664 12.748 5.5664 12.6832V10.2336C5.5664 9.7176 5.984 9.3 6.5 9.3H9.4168C9.4808 9.3 9.5336 9.248 9.5336 9.1832V6.8504C9.5336 6.81942 9.5213 6.78971 9.49939 6.76781C9.47749 6.74591 9.44778 6.7336 9.4168 6.7336H6.9664C6.78075 6.7336 6.6027 6.65985 6.47143 6.52857C6.34015 6.3973 6.2664 6.21925 6.2664 6.0336V5.1C6.2664 4.7136 6.58 4.4 6.9664 4.4H13.0336C13.42 4.4 13.7336 4.7136 13.7336 5.1V6.0336C13.7336 6.21925 13.6599 6.3973 13.5286 6.52857C13.3973 6.65985 13.2193 6.7336 13.0336 6.7336H10.5832C10.5522 6.7336 10.5225 6.74591 10.5006 6.76781C10.4787 6.78971 10.4664 6.81942 10.4664 6.8504V9.1832C10.4664 9.2472 10.5192 9.3 10.5832 9.3H13.5C14.016 9.3 14.4336 9.7176 14.4336 10.2336V12.6832C14.4336 12.7472 14.4856 12.8 14.5496 12.8H14.9Z"
                fill="${bg}"
            />
        </svg>
    `;
};

const headerSingleValue = (props) => {
    const fg = withDefault(props.fgColor, "white");
    const bg = withDefault(props.bgColor, "currentColor");
    return `
        <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
            <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}" />
            <path
                d="M9.97924 13.3273C10.4285 13.3273 10.7186 13.0371 10.7092 12.5786C10.7092 12.5411 10.7092 12.513 10.6999 12.485L10.5408 10.8098L11.9914 11.8579C12.1411 11.9702 12.3002 12.0357 12.4967 12.0357C12.8617 12.0357 13.208 11.7175 13.208 11.2777C13.208 10.9782 13.0395 10.7349 12.7213 10.6039L11.0929 9.82709L12.7213 9.05967C13.0395 8.91929 13.208 8.68532 13.208 8.38584C13.208 7.93663 12.8711 7.62779 12.4967 7.62779C12.3002 7.62779 12.1411 7.6933 11.9914 7.8056L10.5314 8.84442L10.6905 7.1037C10.6999 7.07562 10.6999 7.04755 10.6999 7.01947C10.7092 6.56089 10.4285 6.26141 9.97924 6.26141C9.52066 6.26141 9.22118 6.57961 9.23054 7.01947C9.23054 7.04755 9.23054 7.07562 9.2399 7.1037L9.399 8.84442L7.92968 7.8056C7.79866 7.6933 7.62084 7.62779 7.43366 7.62779C7.05932 7.62779 6.71304 7.94598 6.71304 8.38584C6.71304 8.68532 6.8815 8.91929 7.1997 9.05967L8.82811 9.82709L7.20906 10.5945C6.89086 10.7349 6.71304 10.9689 6.71304 11.2777C6.71304 11.7175 7.05932 12.0264 7.43366 12.0264C7.62084 12.0264 7.7893 11.9702 7.92968 11.8579L9.399 10.8098L9.2399 12.485C9.23054 12.513 9.23054 12.5411 9.23054 12.5786C9.22118 13.0184 9.52066 13.3273 9.97924 13.3273Z"
                fill="${fg}"
            />
        </svg>
    `;
};

const headerLookup = (props) => {
    const fg = withDefault(props.fgColor, "white");
    const bg = withDefault(props.bgColor, "currentColor");
    return `
        <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
            <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}" />
            <path
                d="M7.99976 5.83331H5.83333C5.3731 5.83331 5 6.20641 5 6.66665C5 7.12688 5.3731 7.49998 5.83333 7.49998H7.51868C7.57237 6.90423 7.74006 6.34134 7.99976 5.83331Z"
                fill="${fg}"
            />
            <path
                d="M7.67253 9.16665H5.83333C5.3731 9.16665 5 9.53974 5 9.99998C5 10.4602 5.3731 10.8333 5.83333 10.8333H8.54763C8.14914 10.3508 7.84751 9.7853 7.67253 9.16665Z"
                fill="${fg}"
            />
            <path
                d="M5.83333 12.5C5.3731 12.5 5 12.8731 5 13.3333C5 13.7936 5.3731 14.1666 5.83333 14.1666H13.3333C13.7936 14.1666 14.1667 13.7936 14.1667 13.3333C14.1667 12.8731 13.7936 12.5 13.3333 12.5H5.83333Z"
                fill="${fg}"
            />
            <path
                d="M14.6301 9.59333C14.9174 9.12667 15.0872 8.58667 15.0872 8C15.0872 6.34 13.7748 5 12.1489 5C10.523 5 9.2106 6.34 9.2106 8C9.2106 9.66 10.523 11 12.1424 11C12.717 11 13.2524 10.8267 13.7029 10.5333L15.7401 12.6133L16.6673 11.6667L14.6301 9.59333ZM12.1489 9.66667C11.2478 9.66667 10.5165 8.92 10.5165 8C10.5165 7.08 11.2478 6.33333 12.1489 6.33333C13.05 6.33333 13.7813 7.08 13.7813 8C13.7813 8.92 13.05 9.66667 12.1489 9.66667Z"
                fill="${fg}"
            />
        </svg>
    `;
};

const headerTextTemplate = (props) => {
    const fg = withDefault(props.fgColor, "white");
    const bg = withDefault(props.bgColor, "currentColor");
    return `
        <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
            <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}" />
            <path
                d="M7.67593 4.7265V3L10.6515 6.02137L7.67593 9.04274V7.27308C5.55051 7.27308 4.06272 7.96368 3 9.47436C3.42509 7.31624 4.70034 5.15812 7.67593 4.7265Z"
                fill="${fg}"
            />
            <path
                d="M10.1818 14.4H13.8182L14.4727 16H16L12.5455 8H11.4545L8 16H9.52727L10.1818 14.4ZM12 9.44L13.36 13.0909H10.64L12 9.44Z"
                fill="${fg}"
            />
        </svg>
    `;
};

const headerMath = (props) => {
    const fg = withDefault(props.fgColor, "white");
    const bg = withDefault(props.bgColor, "currentColor");
    return `
        <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
            <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}" />
            <path
                fill-rule="evenodd"
                clip-rule="evenodd"
                d="M4.16668 5.41663C3.70644 5.41663 3.33334 5.78972 3.33334 6.24996C3.33334 6.7102 3.70644 7.08329 4.16668 7.08329H8.33334C8.79358 7.08329 9.16668 6.7102 9.16668 6.24996C9.16668 5.78972 8.79358 5.41663 8.33334 5.41663H4.16668Z"
                fill="${fg}"
            />
            <path
                fill-rule="evenodd"
                clip-rule="evenodd"
                d="M7.08334 4.16665C7.08334 3.70641 6.71025 3.33331 6.25001 3.33331C5.78977 3.33331 5.41668 3.70641 5.41668 4.16665L5.41668 8.33331C5.41668 8.79355 5.78977 9.16665 6.25001 9.16665C6.71025 9.16665 7.08334 8.79355 7.08334 8.33331L7.08334 4.16665Z"
                fill="${fg}"
            />
            <path
                fill-rule="evenodd"
                clip-rule="evenodd"
                d="M11.6667 5.41669C11.2064 5.41669 10.8333 5.78978 10.8333 6.25002C10.8333 6.71026 11.2064 7.08335 11.6667 7.08335H15.8333C16.2936 7.08335 16.6667 6.71026 16.6667 6.25002C16.6667 5.78978 16.2936 5.41669 15.8333 5.41669H11.6667Z"
                fill="${fg}"
            />
            <path
                fill-rule="evenodd"
                clip-rule="evenodd"
                d="M5.36684 11.6883C5.04141 11.3629 4.51377 11.3629 4.18833 11.6883C3.8629 12.0138 3.8629 12.5414 4.18833 12.8668L7.13461 15.8131C7.46005 16.1385 7.98768 16.1385 8.31312 15.8131C8.63856 15.4877 8.63856 14.96 8.31312 14.6346L5.36684 11.6883Z"
                fill="${fg}"
            />
            <path
                fill-rule="evenodd"
                clip-rule="evenodd"
                d="M8.31315 12.8668C8.63859 12.5414 8.63859 12.0138 8.31315 11.6883C7.98771 11.3629 7.46007 11.3629 7.13464 11.6883L4.18836 14.6346C3.86292 14.96 3.86292 15.4877 4.18836 15.8131C4.5138 16.1386 5.04143 16.1386 5.36687 15.8131L8.31315 12.8668Z"
                fill="${fg}"
            />
            <path
                d="M10.8333 12.5C10.8333 12.0398 11.2064 11.6667 11.6667 11.6667H15.8333C16.2936 11.6667 16.6667 12.0398 16.6667 12.5C16.6667 12.9603 16.2936 13.3334 15.8333 13.3334H11.6667C11.2064 13.3334 10.8333 12.9603 10.8333 12.5Z"
                fill="${fg}"
            />
            <path
                d="M10.8333 15C10.8333 14.5398 11.2064 14.1667 11.6667 14.1667H15.8333C16.2936 14.1667 16.6667 14.5398 16.6667 15C16.6667 15.4603 16.2936 15.8334 15.8333 15.8334H11.6667C11.2064 15.8334 10.8333 15.4603 10.8333 15Z"
                fill="${fg}"
            />
        </svg>
    `;
};

const headerRollup = (props) => {
    const fg = withDefault(props.fgColor, "white");
    const bg = withDefault(props.bgColor, "currentColor");
    return `
        <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path
                d="M16.2222 2H3.77778C2.8 2 2 2.8 2 3.77778V16.2222C2 17.2 2.8 18 3.77778 18H16.2222C17.2 18 17.9911 17.2 17.9911 16.2222L18 3.77778C18 2.8 17.2 2 16.2222 2Z"
                fill="${bg}"
            />
            <path
                d="M10.0003 8.83724C9.35812 8.83676 8.83749 9.35738 8.837 9.99953C8.83652 10.6417 9.35714 11.1623 9.9993 11.1628C10.6414 11.1633 11.1621 10.6427 11.1626 10.0005C11.163 9.35835 10.6424 8.83773 10.0003 8.83724ZM13.0195 12.4515C13.7633 11.5313 14.051 10.3238 13.8021 9.16683C13.7472 8.90384 13.4901 8.73516 13.2271 8.79009C12.9641 8.84502 12.7954 9.10217 12.8503 9.36516C13.0399 10.2353 12.8255 11.1443 12.267 11.838C11.2491 13.0868 9.41207 13.274 8.16325 12.2561C6.91443 11.2381 6.72777 9.40113 7.7452 8.1528C7.86332 8.00794 7.99506 7.87474 8.13895 7.75467C8.81513 7.1971 9.70471 6.9696 10.5656 7.1344C10.8286 7.18884 11.0858 7.01967 11.1402 6.75669C11.1946 6.4937 11.0255 6.23655 10.7625 6.1821C10.7562 6.18065 10.7499 6.17967 10.743 6.1787C8.6343 5.77037 6.59409 7.14849 6.18575 9.25724C5.77742 11.366 7.15555 13.4062 9.2643 13.8145C10.6726 14.0872 12.1168 13.5627 13.0214 12.4495L13.0195 12.4515ZM10.0003 4.16669C6.77687 4.16863 4.16548 6.78294 4.16742 10.0063C4.16791 10.7209 4.29964 11.4297 4.55582 12.0966C4.637 12.3523 4.9102 12.4943 5.16638 12.4131C5.42207 12.3319 5.56402 12.0587 5.48284 11.8025C5.477 11.7845 5.47068 11.767 5.46291 11.75C4.49749 9.24655 5.74485 6.43537 8.24784 5.47044C10.7508 4.50551 13.5625 5.75287 14.5274 8.25585C15.4924 10.7588 14.245 13.5705 11.742 14.5354C10.518 15.0075 9.15492 14.9637 7.96346 14.4154C7.71943 14.3026 7.4302 14.409 7.31791 14.6531C7.20513 14.8966 7.3111 15.1859 7.55513 15.2986C8.32124 15.6535 9.15589 15.8358 10.0003 15.8334C13.2217 15.8334 15.8336 13.2215 15.8336 10C15.8336 6.77856 13.2217 4.16669 10.0003 4.16669ZM13.0224 7.67495C13.0224 7.28947 12.7103 6.97738 12.3249 6.97738C11.9394 6.97738 11.6273 7.28947 11.6273 7.67495C11.6273 8.06044 11.9394 8.37252 12.3249 8.37252C12.7099 8.37204 13.0224 8.05995 13.0224 7.67495ZM6.04818 13.0222C6.43367 13.0222 6.74575 13.3343 6.74575 13.7197C6.74575 14.1052 6.43367 14.4173 6.04818 14.4173C5.6627 14.4173 5.35062 14.1052 5.35062 13.7197C5.35062 13.3343 5.6627 13.0222 6.04818 13.0222Z"
                fill="${fg}"
            />
        </svg>
    `;
};

const headerJoinStrings = (props) => {
    const fg = withDefault(props.fgColor, "white");
    const bg = withDefault(props.bgColor, "currentColor");
    return `
        <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
            <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}" />
            <path
                d="M12.3997 13.5649C14.2647 13.02 16.045 11.4819 16.045 9.16875C16.045 7.65491 15.2578 6.56494 13.974 6.56494C12.6903 6.56494 12 7.63069 12 8.93864C13.1142 9.01131 13.8651 9.66529 13.8651 10.622C13.8651 11.5546 13.0657 12.2691 12.0242 12.6445L12.3997 13.5649Z"
                fill="${fg}"
            />
            <rect x="4" y="5" width="6" height="2" fill="${fg}" />
            <rect x="4" y="9" width="5" height="2" fill="${fg}" />
            <rect x="4" y="13" width="4" height="2" fill="${fg}" />
        </svg>
    `;
};

const headerSplitString = (props) => {
    const fg = withDefault(props.fgColor, "white");
    const bg = withDefault(props.bgColor, "currentColor");
    return `
        <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
            <rect x="2" y="2" width="16" height="16" rx="2" fill="${bg}" />
            <path
                d="M8.28564 14.314C10.6167 13.6328 12.8418 11.7104 12.8418 8.81934C12.8418 6.92725 11.8579 5.56494 10.2534 5.56494C8.64893 5.56494 7.78613 6.89697 7.78613 8.53174C9.17871 8.62256 10.1172 9.43994 10.1172 10.6357C10.1172 11.8013 9.11816 12.6943 7.81641 13.1636L8.28564 14.314Z"
                fill="${fg}"
            />
        </svg>
    `;
};

const headerGeoDistance = (props) => {
    const fg = withDefault(props.fgColor, "white");
    const bg = withDefault(props.bgColor, "currentColor");
    return `
        <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path
                d="M16.2222 2H3.77778C2.8 2 2 2.8 2 3.77778V16.2222C2 17.2 2.8 18 3.77778 18H16.2222C17.2 18 17.9911 17.2 17.9911 16.2222L18 3.77778C18 2.8 17.2 2 16.2222 2Z"
                fill="${bg}"
            />
            <path
                d="M10 7C10.5523 7 11 6.55228 11 6C11 5.44772 10.5523 5 10 5V7ZM10 13C9.44772 13 9 13.4477 9 14C9 14.5523 9.44772 15 10 15V13ZM10 5H7V7H10V5ZM7 11H12V9H7V11ZM12 13H10V15H12V13ZM13 12C13 12.5523 12.5523 13 12 13V15C13.6569 15 15 13.6569 15 12H13ZM12 11C12.5523 11 13 11.4477 13 12H15C15 10.3431 13.6569 9 12 9V11ZM4 8C4 9.65685 5.34315 11 7 11V9C6.44772 9 6 8.55228 6 8H4ZM7 5C5.34315 5 4 6.34315 4 8H6C6 7.44772 6.44772 7 7 7V5Z"
                fill="${fg}"
            />
            <path
                fill-rule="evenodd"
                clip-rule="evenodd"
                d="M4.85623 12.0142C4.66241 11.8175 4.34584 11.8152 4.14914 12.009C3.95245 12.2028 3.95012 12.5194 4.14394 12.7161L5.40899 13.9999L4.14385 15.2838C3.95003 15.4805 3.95236 15.7971 4.14906 15.9909C4.34575 16.1847 4.66233 16.1824 4.85615 15.9857L6.11095 14.7123L7.36576 15.9857C7.55958 16.1824 7.87616 16.1847 8.07285 15.9909C8.26954 15.7971 8.27187 15.4805 8.07805 15.2838L6.81291 13.9999L8.07797 12.7161C8.27179 12.5194 8.26946 12.2028 8.07276 12.009C7.87607 11.8152 7.5595 11.8175 7.36568 12.0142L6.11095 13.2876L4.85623 12.0142Z"
                fill="${fg}"
            />
            <path
                fill-rule="evenodd"
                clip-rule="evenodd"
                d="M12.8562 4.01423C12.6624 3.81754 12.3458 3.81521 12.1491 4.00903C11.9524 4.20285 11.9501 4.51942 12.1439 4.71612L13.409 5.99993L12.1439 7.28383C11.95 7.48053 11.9524 7.7971 12.1491 7.99092C12.3458 8.18474 12.6623 8.18241 12.8561 7.98572L14.111 6.7123L15.3658 7.98572C15.5596 8.18241 15.8762 8.18474 16.0728 7.99092C16.2695 7.7971 16.2719 7.48053 16.0781 7.28383L14.8129 5.99993L16.078 4.71612C16.2718 4.51942 16.2695 4.20285 16.0728 4.00903C15.8761 3.81521 15.5595 3.81754 15.3657 4.01423L14.111 5.28756L12.8562 4.01423Z"
                fill="${fg}"
            />
        </svg>
    `;
};

const rowOwnerOverlay = (props) => {
    const fg = withDefault(props.fgColor, "white");
    const bg = withDefault(props.bgColor, "currentColor");
    return `
        <svg width="18" height="18" viewBox="0 0 18 18" fill="none" xmlns="http://www.w3.org/2000/svg">
            <g clipPath="url(#clip0)">
                <path
                    d="M2 15V16H3H15H16V15V13.5C16 12.634 15.5582 11.9494 15.0223 11.4548C14.4932 10.9664 13.8087 10.5984 13.1228 10.3236C12.3333 10.0073 11.4587 9.78207 10.6437 9.64796C12.0333 9.02114 13 7.62385 13 6C13 3.79022 11.2098 2 9 2C6.79022 2 5 3.79022 5 6C5 7.62386 5.96672 9.02114 7.35626 9.64797C6.54129 9.78207 5.6667 10.0073 4.87719 10.3236C4.19132 10.5984 3.50678 10.9664 2.97767 11.4548C2.44177 11.9494 2 12.634 2 13.5V15Z"
                    fill="${bg}"
                    stroke="${fg}"
                    stroke-width="2"
                />
            </g>
            <defs>
                <clipPath id="clip0">
                    <rect width="18" height="18" fill="white" />
                </clipPath>
            </defs>
        </svg>
    `;
};

const protectedColumnOverlay = (props) => {
    const fg = withDefault(props.fgColor, "white");
    const bg = withDefault(props.bgColor, "currentColor");
    return `
    <svg width="18" height="18" viewBox="0 0 18 18" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path 
            d="M12.4286 6.04312V5.85714C12.4286 3.72772 10.7009 2 8.57143 2C6.442 2 4.71429 3.72772 4.71429 5.85714V6.04312C3.73781 6.24242 3 7.10871 3 8.14286V13.8571C3 15.038 3.962 16 5.14286 16H12C13.1809 16 14.1429 15.038 14.1429 13.8571V8.14286C14.1429 7.10871 13.405 6.24242 12.4286 6.04312ZM7.85714 6V5.85714C7.85714 5.46086 8.17514 5.14286 8.57143 5.14286C8.96772 5.14286 9.28571 5.46086 9.28571 5.85714V6H7.85714Z" 
            fill="${bg}" 
            stroke="${fg}" 
            stroke-width="2"/>
    </svg>
`;
};

// Light theme
const builderThemeBase = {
    overlayName: "LightTheme",
    darkGrey: "#313139",

    fgColorDarkest: "#000000",
    fgColorDark: "#313139",
    fgColorMedium: "#737383",
    fgColorLight: "#B2B2C0",

    bgColorLight: "#FFFFFF",

    borderColor: "#D8D8E3",

    bgColorAltLight: "#FAFAFB",

    acceptColor: "#4F5DFF",

    linkColor: "#4F5DFF",

    dataViewer: {
        fgAddButton: "#4F5DFF",
        bgColor: "#FFFFFF",
        gridColor: "#FFFFFF",
        leftMargin: "0px",
        bgSelected: "rgba(79, 93, 255, 0.1)",
        bgBubble: "#EDEDF3",
        bgBubbleSelected: "#FFFFFF",
        bgPrelight: "#fff9e3",

        checkbox: {
            checkedColor: "#4F5DFF",
        },
        columnHeader: {
            bgColor: "#EDEDF3",
            bgDark: "#D8D8E3",
            fgColor: "#737383",
            fgSelected: "#FFFFFF",
            bgSelected: "#4F5DFF",

            icon: {
                bgColor: "#313139",
                fgColor: "#FFFFFF",
                bgColorSelected: "#FFFFFF",
                fgColorSelected: "#4F5DFF",

                userSpecific: {
                    bgColor: "#4F5DFF",
                    fgColor: "#FFFFFF",
                    bgColorSelected: "#FFFFFF",
                    fgColorSelected: "#4F5DFF",
                },
            },
        },
    },
};

export const ScrollRegionStyle = styled.div`
    .dvn-scroller {
        overflow: ${browserIsSafari ? "scroll" : "auto"};
        transform: translate3d(0, 0, 0);
    }

    .dvn-scroll-inner {
        pointer-events: none;
    }

    .dvn-underlay > * {
        position: absolute;
        left: 0;
        top: 0;
    }

    canvas {
        outline: none;
    }
`;

const ScrollRegion = p => {
    const { className, scrollWidth, scrollHeight, style, children, update, scrollToEnd, scrollRef } = p;

    const innerStyle = React.useMemo(
        () => ({
            width: scrollWidth,
            height: scrollHeight,
            contain: "size paint layout",
        }),
        [scrollWidth, scrollHeight]
    );

    const scroller = React.useRef(null);

    const onScroll = React.useCallback(() => {
        const el = scroller.current;
        if (el === null) return;
        update({
            clientHeight: el.clientHeight - (isFirefox ? 4 : 0),
            clientWidth: el.clientWidth,
            scrollLeft: Math.max(0, el.scrollLeft),
            scrollTop: Math.max(0, el.scrollTop),
        });
    }, [update]);

    React.useEffect(() => {
        const el = scroller.current;
        if (el === null || scrollToEnd !== true) return;

        el.scrollLeft = el.scrollWidth - el.clientWidth;
    }, [scrollToEnd]);

    const setRefs = React.useCallback(
        (instance) => {
            scroller.current = instance;
            if (scrollRef !== undefined) {
                scrollRef.current = instance;
            }
        },
        [scrollRef]
    );

    const lastProps = React.useRef();

    return (
        <div style={style}>
            <AutoSizer>
                {(props) => {
                    if (props.width === 0 || props.height === 0) return null;
                    if (lastProps.currentheight !== props.height || lastProps.currentwidth !== props.width) {
                        window.setTimeout(onScroll, 0);
                        lastProps.current = props;
                    }

                    return (
                        <ScrollRegionStyle>
                            <div className="dvn-underlay">{children}</div>
                            <div
                                ref={setRefs}
                                style={props}
                                className={"dvn-scroller " + className}
                                onScroll={onScroll}>
                                <div className="dvn-scroll-inner" style={innerStyle} />
                            </div>
                        </ScrollRegionStyle>
                    );
                }}
            </AutoSizer>
        </div>
    );
};

const styled = baseStyled;

function getBuilderTheme() {
    return builderThemeBase;
}

const digitsAndLetters = Array.from("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
    .sort()
    .join("");

/* eslint-disable */
const emailDomainRegexp = /^@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])$/;
const emailAddressRegexp = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
/* eslint-enable */

function isValidEmailAddress(s) {
    return emailAddressRegexp.test(s);
}

// FIXME: Isso não pertence aqui
const MaxPinLifeMins = 15;

// Isso existe apenas para evitar que o preenchimento automático com erros coloque códigos postais nos nomes das guias.
//
// Seria muito legal se o Chrome fosse compatível com os padrões da web reais.
// Você deve ser capaz de dizer `autocomplete =" off "` como um atributo para desativá-lo,
// mas o Chrome se recusa terminantemente a oferecer suporte a isso (consulte https://bugs.chromium.org/p/chromium/issues/detail?id=468153#c164)
// O que eles recomendam que façamos em vez disso é "definir uma tag semântica". Então, aqui está o significado semântico de _este_ atributo:
// pare o preenchimento automático, seus idiotas.
//
// Isso funciona no Chrome e no Firefox, mas não no Safari. No momento, o preenchimento automático do Safari
// não fez nada catastrófico, então talvez tenhamos que viver com isso.
const disableBrowserAutocompleteToken = "browsers-should-never-autocomplete-this";

function checkBoolean(x) {
    if (typeof x === "boolean") return x;
    return panic(`Value should be a boolean: ${x}`);
}

function checkString(x) {
    if (typeof x === "string") return x;
    return panic(`Value should be a string: ${x}`);
}

function checkNumber(x) {
    if (typeof x === "number") return x;
    return panic(`Value should be a number: ${x}`);
}

function isArray(x)  {
    return Array.isArray(x);
}

function checkArray(x, checkItem) {
    if (!Array.isArray(x)) {
        return panic(`O valor deve ser uma matriz: ${x}`);
    }
    if (checkItem !== undefined) {
        x.forEach(checkItem);
    }
    return x;
}

export function proveType(_val) {
    // não faça nada, apenas prove que o compilador acha que os tipos correspondem
}

export function proveNever(_never, _message, result) {
    return result;
}

export function panic(message = "Isso não deveria acontecer") {
    throw new Error(message);
}

function assert(fact, message = "A afirmação falhou") {
    if (fact) return;
    return panic(message);
}

function assertNever(_never) {
    return panic("Hell froze over");
}

function defined(v, reason) {
    if (v === undefined)
        return panic(
            "O valor estava indefinido, mas deve ser definido" +
                (reason !== undefined ? `, esperado para ser definido porque: ${reason}` : "")
        );
    return v;
}

function nonNull(v) {
    if (v === null) return panic("O valor era nulo, mas não deveria ser nulo");
    return v;
}

function isUndefinedish(v) {
    return v === null || v === undefined;
}

function isEmptyOrUndefined(v) {
    return v === undefined || v.length === 0;
}

function isEmptyOrUndefinedish(v) {
    return v === undefined || v === null || v.length === 0;
}

function nullToUndefined(v) {
    if (v === null) return undefined;
    return v;
}

function definedMapWithDefault(v, defaultValue, f) {
    if (v === undefined) {
        return defaultValue;
    }
    return f(v);
}

function definedishMapWithDefault(v, defaultValue, f) {
    if (isUndefinedish(v)) {
        return defaultValue;
    }
    return f(v);
}

function truthify(x) {
    return !!x;
}

// Isso o torna seguro para tipos
function fillArray(length, value) {
    return new Array(length).fill(value);
}

function dontAwait(p) {
    p.catch(e => {
        throw e;
    });
}

function removeArrayItem(arr, index) {
    return [...arr.slice(0, index), ...arr.slice(index + 1)];
}

function maybe(fn, defaultValue) {
    try {
        const result = fn();
        return result;
    } catch {
        return defaultValue;
    }
}

function useEventListener(
    eventName,
    handler,
    element,
    passive,
    capture
) {
    capture = capture ? capture: false;
    // Cria um ref que armazena o manipulador
    const savedHandler = React.useRef();

    // Atualize o valor ref.current se o manipulador mudar.
    // Isso permite que nosso efeito abaixo sempre obtenha o manipulador mais recente ...
    // ... sem que precisemos passá-lo em array deps de efeito ...
    // ... e potencialmente causar efeito ao executar novamente cada renderização.
    React.useEffect(() => {
        savedHandler.current = handler;
    }, [handler]);

    React.useEffect(
        () => {
            // Certifique-se de que o elemento seja compatível com addEventListener
            if (element === null || element.addEventListener === undefined) return;
            const el = element;

            // Cria ouvinte de evento que chama a função de manipulador armazenada em ref
            const eventListener = (event) => {
                savedHandler.currentcall(el, event);
            };

            el.addEventListener(eventName, eventListener, { passive, capture });

            // Remover ouvinte de evento na limpeza
            return () => {
                el.removeEventListener(eventName, eventListener);
            };
        },
        [eventName, element, passive, capture] // Executar novamente se eventName ou elemento mudar
    );
}
const PI = Math.PI;
export function degreesToRadians(degrees) {
    return (degrees * PI) / 180;
}

const disabledProps = css`
    opacity: 0.4;
    pointer-events: none;
`;

const EditPencil = (props) => {
    const bg = props.bgColor ? props.bgColor: "currentColor";
    const fg = props.fgColor ? props.fgColor: "#ffffff";
    return (
        <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
            <circle cx="8" cy="8" r="8" fill={bg} />
            <path
                d="M4.25 10.1874V11.7499H5.8125L10.4208 7.14161L8.85833 5.57911L4.25 10.1874ZM11.6292 5.93328C11.7917 5.77078 11.7917 5.50828 11.6292 5.34578L10.6542 4.37078C10.4917 4.20828 10.2292 4.20828 10.0667 4.37078L9.30417 5.13328L10.8667 6.69578L11.6292 5.93328V5.93328Z"
                fill={fg}
            />
        </svg>
    );
};

const MarkdownContainer = styled.div`
    word-break: break-word;
    -webkit-touch-callout: default;

    & *:last-child {
        margin-bottom: 0;
    }

    & p img {
        width: 100%;
    }
`;

class MarkdownDiv extends React.PureComponent {
    targetElement = null;

    renderMarkdownIntoDiv() {
        const { targetElement } = this;
        if (targetElement === null) return;

        const { contents, linkOnClick, createNode } = this.props;

        const innerHTML = (marked)(contents);

        const childRange = document.createRange();
        childRange.selectNodeContents(targetElement);
        childRange.deleteContents();

        let newChild = createNode(innerHTML);
        if (newChild === undefined) {
            const childDoc = document.createElement("template");
            childDoc.innerHTML = innerHTML;
            newChild = childDoc.content;
        }
        targetElement.appendChild(newChild);

        if (linkOnClick !== undefined) {
            const tags = targetElement.getElementsByTagName("a");
            for (let i = 0; i < tags.length; i++) {
                const tag = tags[i];
                tag.onclick = () => {
                    linkOnClick(tag.href);
                };
            }
        }
    }

    containerRefHook = (element) => {
        this.targetElement = element;
        this.renderMarkdownIntoDiv();
    };

    render() {
        // Fazer isso no gancho ref funciona muito bem na primeira renderização, mas nunca mais.
        // Isso só funciona bem após a primeira renderização, mas não na primeira renderização.
        // Juntar os dois cria a solução completa.
        this.renderMarkdownIntoDiv();
        return <MarkdownContainer ref={this.containerRefHook} />;
    }
}

const { userAgent } = window.navigator;

const browserIsSafari =
    userAgent.indexOf("Mac OS") > -1 && userAgent.indexOf("Safari") > -1 && userAgent.indexOf("Chrome") < 0;
const browserIsOSX = lazy(() => window.navigator.platform.toLowerCase().startsWith("mac"));
const isFirefox = userAgent.includes("Firefox");

const GridCellKind = {
    Uri : "uri",
    Text : "text",
    Image : "image",
    RowID : "row-id",
    Number : "number",
    Bubble : "bubble",
    Boolean : "boolean",
    Loading : "loading",
    Markdown : "markdown",
    Protected : "protected",
}

export function isEditableGridCell(cell) {
    if (
        cell.kind === GridCellKind.Loading ||
        cell.kind === GridCellKind.Bubble ||
        cell.kind === GridCellKind.RowID ||
        cell.kind === GridCellKind.Protected
    ) {
        return false;
    }

    proveType(cell);
    return true;
}

export function makeEditCell(cell) {
    const isEditable = isEditableGridCell(cell);

    switch (cell.kind) {
        case GridCellKind.Boolean:
            return {
                ...cell,
                data: false,
            };
        case GridCellKind.Text:
            return {
                ...cell,
                data: "",
                displayData: "",
            };
        case GridCellKind.Markdown:
        case GridCellKind.Uri:
        case GridCellKind.RowID:
            return {
                ...cell,
                data: "",
                allowOverlay: isEditable,
            };
        case GridCellKind.Protected:
        case GridCellKind.Loading:
            return cell;
        case GridCellKind.Image:
        case GridCellKind.Bubble:
            return {
                ...cell,
                data: [],
                allowOverlay: isEditable,
            };
        case GridCellKind.Number:
            return {
                ...cell,
                data: undefined,
                displayData: "",
            };
        default:
            assertNever(cell);
    }
}

const AnterosAdvancedTableEditor = p => {
    const [gridSelectionInner, setGridSelectionInner] = React.useState();
    const [selectedRows, setSelectedRows] = React.useState([]);
    const [selectedColumns, setSelectedColumns] = React.useState([]);
    const [hoveredCell, setHoveredCell] = React.useState();
    const [overlay, setOverlay] = React.useState();
    const canvasRef = React.useRef(null);
    const mouseState = React.useRef();
    const scrollRef = React.useRef(null);
    const scrollTimer = React.useRef();
    const lastSent = React.useRef();

    const imageEditorOverride = p.imageEditorOverride;
    const markdownDivCreateNode = p.markdownDivCreateNode;
    const rowMarkers = p.rowMarkers ? p.rowMarkers: true;
    const showTrailingBlankRow = p.showTrailingBlankRow ? p.showTrailingBlankRow: true;
    const rowMarkerOffset = rowMarkers ? 1 : 0;

    const rowHeight = p.rowHeight ? p.rowHeigh:  34;
    const headerHeight = p.headerHeight ? p.headerHeight: 36;
    const rowMarkerWidth = p.rowMarkerWidth ? p.rowMarkerWidth: 50;

    const { isDraggable, getCellsForSelection } = p;

    const {
        cellXOffset: xOff,
        cellYOffset: yOff,
        columns,
        rows,
        getCellContent,
        onCellClicked,
        onCellEdited,
        onRowAppended,
        onColumnMoved,
        onDeleteRows,
        onDragStart,
        onHeaderMenuClick,
        onVisibleRegionChanged,
        gridSelection: gridSelectionOuter,
        onGridSelectionChange,
        ...rest
    } = p;

    const gridSelection = gridSelectionOuter ? gridSelectionOuter:  gridSelectionInner;
    const setGridSelection = onGridSelectionChange ? onGridSelectionChange: setGridSelectionInner;

    const hoveredFirstRow = hoveredCell[0] === 0 ? hoveredCell[1] : undefined;

    const focus = React.useCallback(() => {
        window.requestAnimationFrame(() => {
            canvasRef.currentfocus();
        });
    }, []);

    const mangledRows = showTrailingBlankRow ? rows + 1 : rows;

    const mangledOnCellEdited = React.useCallback(
        (cell, newValue => {
            const [, row] = cell;
            if (showTrailingBlankRow && row === mangledRows - 1) {
                onRowAppended(cell, newValue);
            } else {
                onCellEdited(cell, newValue);
            }
        },
        [onRowAppended, onCellEdited, mangledRows, showTrailingBlankRow]
    ));

    const mangledCols = React.useMemo(() => {
        if (!rowMarkers) return columns;
        return [
            {
                title: "",
                width: rowMarkerWidth,
                icon: undefined,
                hasMenu: false,
                style: "normal",
            },
            ...columns,
        ];
    }, [columns, rowMarkerWidth, rowMarkers]);

    const getMangedCellContent = React.useCallback(
        ([col, row]) => {
            if (col === 0 && rowMarkers) {
                return {
                    kind: GridCellKind.Boolean,
                    data: selectedRowsincludes(row),
                    showUnchecked: hoveredFirstRow === row,
                    allowOverlay: false,
                    allowEdit: false,
                };
            } else if (showTrailingBlankRow && row === mangledRows - 1) {
               // Se a GRID estiver vazia, retornaremos o texto
                if (row === 0) {
                    return {
                        kind: GridCellKind.Text,
                        displayData: "",
                        data: "",
                        allowOverlay: true,
                    };
                }
                // Baseie o dataType na linha anterior.
                const previousRow = getCellContent([col - rowMarkerOffset, row - 1]);
                return makeEditCell(previousRow);
            } else {
                return getCellContent([col - rowMarkerOffset, row]);
            }
        },
        [rowMarkers, showTrailingBlankRow, mangledRows, selectedRows, hoveredFirstRow, getCellContent, rowMarkerOffset]
    );

    const onMouseDown = React.useCallback(
        (args) => {
            mouseState.current = {
                previousSelection: gridSelection,
            };
            if (args.kind === "cell") {
                const [col, row] = args.location;
                if (col === 0 && rowMarkers) {
                    setGridSelection(undefined);
                    setOverlay(undefined);
                    focus();
                    setSelectedColumns([]);

                    const index = selectedRows.indexOf(row);
                    if (index !== -1) {
                        setSelectedRows(removeArrayItem(selectedRows, index));
                    } else {
                        setSelectedRows([...selectedRows, row]);
                    }
                } else {
                    if (gridSelectioncell[0] !== col || gridSelection.cell[1] !== row) {
                        if (args.shiftKey && gridSelection !== undefined) {
                            const [sCol, sRow] = gridSelection.cell;
                            const left = Math.min(col, sCol);
                            const right = Math.max(col, sCol);
                            const top = Math.min(row, sRow);
                            const bottom = Math.max(row, sRow);
                            setGridSelection({
                                ...gridSelection,
                                range: {
                                    x: left,
                                    y: top,
                                    width: right - left + 1,
                                    height: bottom - top + 1,
                                },
                            });
                        } else {
                            setGridSelection({ cell: [col, row], range: { x: col, y: row, width: 1, height: 1 } });
                            setSelectedColumns([]);
                            setSelectedRows([]);
                            setOverlay(undefined);
                            focus();
                        }
                    }
                }
            } else if (args.kind === "header") {
                const [col] = args.location;
                setSelectedColumns([col]);
                setGridSelection(undefined);
                setOverlay(undefined);
                focus();
                setSelectedRows([]);
            } else if (args.kind === "out-of-bounds") {
                setGridSelection(undefined);
                setOverlay(undefined);
                focus();
                setSelectedColumns([]);
                setSelectedRows([]);
            }
        },
        [gridSelection, rowMarkers, setGridSelection, focus, selectedRows]
    );

    const reselect = React.useCallback(
        (bounds, initialValue) => {
            if (gridSelection === undefined) return;

            const [col, row] = gridSelection.cell;
            const c = getMangedCellContent([col, row]);
            if (c.kind !== GridCellKind.Boolean && c.allowOverlay) {
                let content = c;
                if (initialValue !== undefined) {
                    switch (content.kind) {
                        case GridCellKind.Number:
                            content = {
                                ...content,
                                data: maybe(() => Number.parseFloat(initialValue), 0),
                            };
                            break;
                        case GridCellKind.Text:    
                        case GridCellKind.Markdown:
                        case GridCellKind.Uri:
                            content = {
                                ...content,
                                data: initialValue,
                            };
                            break;
                    }
                }
                setOverlay({
                    target: bounds,
                    content,
                    cell: [col, row],
                    forceEditMode: initialValue !== undefined,
                });
            } else if (c.kind === GridCellKind.Boolean) {
                mangledOnCellEdited([col - rowMarkerOffset, row], {
                    ...c,
                    data: !c.data,
                });
            } else {
                onCellClicked([col - rowMarkerOffset, row]);
            }
        },
        [getMangedCellContent, mangledOnCellEdited, onCellClicked, rowMarkerOffset, gridSelection]
    );

    const onMouseUp = React.useCallback(
        (args) => {
            const mouse = mouseState.current;
            mouseState.current = undefined;

            if (scrollTimer.current !== undefined) {
                window.clearInterval(scrollTimer.current);
            }

            if (args.kind !== "cell" || gridSelection === undefined || mousepreviousSelectioncell === undefined)
                return;
            const [col, row] = args.location;
            const [selectedCol, selectedRow] = gridSelection.cell;
            const [prevCol, prevRow] = mouse.previousSelection.cell;
            if (col === selectedCol && col === prevCol && row === selectedRow && row === prevRow) {
                reselect(args.bounds);
            }
        },
        [gridSelection, reselect]
    );

    const onHeaderMenuClickInner = React.useCallback(
        (col, screenPosition) => {
            onHeaderMenuClick(col - rowMarkerOffset, screenPosition);
        },
        [onHeaderMenuClick, rowMarkerOffset]
    );

    const [visibileRegion, setVisibleRegion] = React.useState({ x: 0, y: 0, width: 1, height: 1 });

    const cellXOffset = xOff ? xOff: visibileRegion.x;
    const cellYOffset = yOff ? yOff: visibileRegion.y;

    const onVisibleRegionChangedImpl = React.useCallback(
        (visibleRegion, tx, ty) => {
            const newRegion = {
                ...visibleRegion,
                x: visibleRegion.x - rowMarkerOffset,
                height:
                    showTrailingBlankRow && visibleRegion.y + visibleRegion.height >= rows
                        ? visibleRegion.height - 1
                        : visibleRegion.height,
                tx,
                ty
            };
            setVisibleRegion(newRegion);
            onVisibleRegionChanged(newRegion);
        },
        [onVisibleRegionChanged, rowMarkerOffset, rows, showTrailingBlankRow]
    );

    const onColumnMovedImpl = React.useCallback(
        (startIndex, endIndex) => {
            onColumnMoved(startIndex - rowMarkerOffset, endIndex - rowMarkerOffset);
            setSelectedColumns([endIndex]);
        },
        [onColumnMoved, rowMarkerOffset]
    );

    const onDragStartImpl = React.useCallback(
        (args) => {
            onDragStart({
                ...args,
                location: [args.location[0] - rowMarkerOffset, args.location[1]],
            });
        },
        [onDragStart, rowMarkerOffset]
    );

    const onItemHovered = React.useCallback(
        (args) => {
            if (args.kind === "cell") {
                setHoveredCell(args.location);
            } else if (args.kind === "out-of-bounds") {
                setHoveredCell(undefined);
            }

            if (mouseState.current !== undefined && gridSelection !== undefined && !isDraggable) {
                const [selectedCol, selectedRow] = gridSelection.cell;
                // eslint-disable-next-line prefer-const
                let [col, row] = args.location;

                if (col === 0 && rowMarkers) {
                    col = 1;
                }

                const deltaX = col - selectedCol;
                const deltaY = (row ? row: 0) - selectedRow;

                const newRange = {
                    x: deltaX >= 0 ? selectedCol : col,
                    y: deltaY >= 0 ? selectedRow : row ? row : 0,
                    width: Math.abs(deltaX) + 1,
                    height: Math.abs(deltaY) + 1,
                };

                setGridSelection({
                    ...gridSelection,
                    range: newRange,
                });

                if (args.kind === "out-of-bounds" && scrollRef.current !== null) {
                    const [horizontal, vertical] = args.direction;
                    let scrollX = 0;
                    let scrollY = 0;
                    if (horizontal === -1) {
                        scrollX = columns[columns.length - 1].width;
                    } else if (horizontal === 1) {
                        scrollX = -columns[0].width;
                    }
                    if (vertical !== 0) {
                        scrollY = rowHeight * vertical;
                    }

                    if (scrollTimer.current !== undefined) {
                        window.clearInterval(scrollTimer.current);
                    }
                    scrollTimer.current = window.setInterval(() => {
                        scrollRef.currentscrollBy(-100 * horizontal, scrollY);
                    }, 200);
                    scrollRef.current.scrollBy(scrollX, scrollY);
                } else {
                    if (scrollTimer.current !== undefined) {
                        window.clearInterval(scrollTimer.current);
                    }
                }
            }
        },
        [gridSelection, isDraggable, rowMarkers, setGridSelection, columns, rowHeight]
    );

    const copyToClipboard = React.useCallback((cells) => {
        function escape(_str) {
            if (/\n|"/.test(_str)) {
                _str = `"${_str.replace(`"`, `""`)}"`;
            }
            return _str;
        }

        const formatCell = (cell) => {
            switch (cell.kind) {
                case GridCellKind.Text:
                case GridCellKind.Number:
                    return escape(cell.displayData);
                case GridCellKind.Markdown:
                case GridCellKind.RowID:
                case GridCellKind.Uri:
                    return escape(cell.data);
                case GridCellKind.Image:
                case GridCellKind.Bubble:
                    return cell.data.reduce((pv, cv) => `${escape(pv)},${escape(cv)}`);
                case GridCellKind.Boolean:
                    return cell.data ? "TRUE" : "FALSE";
                case GridCellKind.Loading:
                    return "#LOADING";
                case GridCellKind.Protected:
                    return "************";
                default:
                    assertNever(cell);
            }
        };

        const str = cells.map(row => row.map(formatCell).join("\t")).join("\n");
        copy(str, {
            format: "text/plain",
        });
    }, []);

    const adjustSelection = React.useCallback(
        (direction) => {
            if (gridSelection === undefined) return;

            const [x, y] = direction;
            const [col, row] = gridSelection.cell;

            let left = oldRangex ? oldRangex : col;
            let top = oldRangey ? oldRangey: row;

            let width = oldRangewidth ? oldRangewidth: 1;
            let height = oldRangeheight ? oldRangeheight: 1;

            const topDiff = top - row;
            const leftDiff = left - col;

            let isTop = topDiff === 0;
            if (y < 0 && height === 1) isTop = false;
            const heightDiff = isTop ? y : y * -1;

            let isLeft = leftDiff === 0;
            if (x < 0 && width === 1) isLeft = false;
            const widthDiff = isLeft ? x : x * -1;

            if (!isTop) {
                top -= heightDiff;
                height = Math.abs(top - row) + 1;
            } else {
                const maxHeight = rows - top;
                height += heightDiff;
                height = Math.min(maxHeight, height);
            }

            if (!isLeft) {
                left -= widthDiff;
                //Don't let it select the marker column
                left = Math.max(rowMarkerOffset, left);
                width = Math.abs(left - col) + 1;
            } else {
                width += widthDiff;
            }

            setGridSelection({
                ...gridSelection,
                range: {
                    x: left,
                    y: top,
                    width: width,
                    height: height,
                },
            });
        },
        [gridSelection, rowMarkerOffset, rows, setGridSelection]
    );

    const updateSelectedCell = React.useCallback(
        (col, row) => {
            col = clamp(rowMarkerOffset, columns.length, col);
            row = clamp(0, mangledRows - 1, row);
            if (col === gridSelectioncell[0] && row === gridSelectioncell[1]) return false;
            setGridSelection({ cell: [col, row], range: { x: col, y: row, width: 1, height: 1 } });

            if (lastSent.current !== undefined && lastSent.current[0] === col && lastSent.current[1] === row) {
                lastSent.current = undefined;
            }

            if (scrollRef.current !== null) {
                const { clientWidth, clientHeight } = scrollRef.current;

                const maxXScrollToCol = (index) => {
                    if (index <= 1) return 0;
                    const widths = mangledCols.slice(undefined, index - 1).map(c => c.width);
                    const total = widths.reduce((pv, cv) => pv + cv);
                    return total + 1;
                };

                const minXScrollToCol = (index) => {
                    const maxX = maxXScrollToCol(index);
                    const availableSpace = clientWidth - (rowMarkers ? rowMarkerWidth : 0) - mangledCols[index].width;
                    let offset = 0;
                    for (let i = index - 1; i >= 0; i--) {
                        if (availableSpace - (offset + mangledCols[i].width) < 0) break;
                        offset += mangledCols[i].width;
                    }
                    return maxX - offset;
                };

                let visibleFullColumns = 0;
                let t = rowMarkers ? rowMarkerWidth : 0;
                for (let c = cellYOffset; c < columns.length; c++) {
                    if (t + columns[c].width > clientWidth) break;

                    visibleFullColumns++;
                    t += columns[c].width;
                }

                const visible = {
                    x: cellXOffset + 1,
                    y: cellYOffset,
                    width: visibleFullColumns,
                    height: Math.ceil((clientHeight - headerHeight) / rowHeight),
                };

                if (row >= visible.y + visible.height - 1) {
                    const delta = row - (visible.y + visible.height - 2);
                    scrollRef.current.scrollBy(0, rowHeight * delta);
                } else if (row < visible.y) {
                    const delta = visible.y - row;
                    scrollRef.current.scrollBy(0, -(rowHeight * delta));
                } else if (col >= visible.x + visible.width) {
                    scrollRef.current.scrollLeft = minXScrollToCol(col);
                } else if (col < visible.x) {
                    scrollRef.current.scrollLeft = maxXScrollToCol(col);
                }
            }

            return true;
        },
        [
            rowMarkerOffset,
            columns,
            mangledRows,
            gridSelectioncell,
            setGridSelection,
            rowMarkers,
            rowMarkerWidth,
            cellXOffset,
            cellYOffset,
            headerHeight,
            rowHeight,
            mangledCols,
        ]
    );

    const onFinishEditing = React.useCallback(
        (newValue, movement) => {
            if (gridSelection !== undefined && newValue !== undefined) {
                mangledOnCellEdited(
                    [gridSelection.cell[0] - rowMarkerOffset, gridSelection.cell[1]],
                    newValue
                );
            }
            setOverlay(undefined);
            focus();

            const [movX, movY] = movement;
            if (gridSelection !== undefined && (movX !== 0 || movY !== 0)) {
                updateSelectedCell(gridSelection.cell[0] + movX, gridSelection.cell[1] + movY);
            }
        },
        [gridSelection, focus, mangledOnCellEdited, rowMarkerOffset, updateSelectedCell]
    );

    const onKeyDown = React.useCallback(
        (event) => {
            const fn = async () => {
                const shiftKey = event.shiftKey;
                const isDeleteKey = event.key === "Delete" || (browserIsOSX.value && event.key === "Backspace");
                const isCopyKey = event.key === "c" && (event.metaKey || event.ctrlKey);

                if (event.key === "Escape") {
                    setGridSelection(undefined);
                    setSelectedRows([]);
                    setSelectedColumns([]);
                    return;
                }

                if (isDeleteKey && selectedRows.length !== 0 && gridSelection === undefined) {
                    focus();
                    onDeleteRows(selectedRows);
                    setSelectedRows([]);
                    return;
                }

                if (isCopyKey && getCellsForSelection !== undefined) {
                    if (gridSelection !== undefined) {
                        const [_col, _row] = gridSelection.cell;
                        if (gridSelection.range !== undefined && getCellsForSelection !== undefined) {
                            copyToClipboard(
                                getCellsForSelection({
                                    ...gridSelection.range,
                                    x: gridSelection.range.x - rowMarkerOffset,
                                })
                            );
                        } else {
                            const cellValue = getCellContent([_col - rowMarkerOffset, _row]);
                            copyToClipboard([[cellValue]]);
                        }
                    } else if (selectedRows.length > 0) {
                        const cells = selectedRows.map(
                            rowIndex =>
                                getCellsForSelection({
                                    x: 0,
                                    y: rowIndex,
                                    width: columns.length,
                                    height: 1,
                                })[0]
                        );
                        copyToClipboard(cells);
                    } else if (selectedColumns.length === 1) {
                        copyToClipboard(
                            getCellsForSelection({
                                x: selectedColumns[0] - rowMarkerOffset,
                                y: 0,
                                width: 1,
                                height: rows,
                            })
                        );
                    }
                }

                if (gridSelection === undefined) return;
                let [col, row] = gridSelection.cell;

                if (event.key === "Enter" && event.bounds !== undefined) {
                    reselect(event.bounds);
                    event.cancel();
                } else if (event.key === "v" && (event.metaKey || event.ctrlKey)) {
                    try {
                        const text = await navigator.clipboard.readText();
                        const cellValue = getCellContent([col - rowMarkerOffset, row]);

                        if (!isEditableGridCell(cellValue)) return;

                        switch (cellValue.kind) {
                            case GridCellKind.Markdown:
                            case GridCellKind.Uri:
                            case GridCellKind.Text:
                                mangledOnCellEdited([col - rowMarkerOffset, row], {
                                    ...cellValue,
                                    data: text,
                                });
                                break;
                        }
                    } catch {
                        // não faça nada
                    }
                } else if (event.key === "ArrowDown") {
                    if (shiftKey) {
                        adjustSelection([0, 1]);
                    } else {
                        row++;
                    }
                } else if (event.key === "ArrowUp") {
                    if (shiftKey) {
                        adjustSelection([0, -1]);
                    } else {
                        row--;
                    }
                } else if (event.key === "ArrowRight") {
                    if (shiftKey) {
                        adjustSelection([1, 0]);
                    } else {
                        col++;
                    }
                } else if (event.key === "ArrowLeft") {
                    if (shiftKey) {
                        adjustSelection([-1, 0]);
                    } else {
                        col--;
                    }
                } else if (event.key === "Tab") {
                    if (shiftKey) {
                        col--;
                    } else {
                        col++;
                    }
                } else if (isDeleteKey) {
                    const cellValue = getCellContent([col - rowMarkerOffset, row]);
                    if (isEditableGridCell(cellValue) && cellValue.allowOverlay) {
                        // FIXME: Adicionar forma de mostrar o modal de confirmação
                        const del = true;
                        focus();
                        const cell = [col - rowMarkerOffset, row];
                        if (del) {
                            switch (cellValue.kind) {
                                case GridCellKind.Text:
                                case GridCellKind.Markdown:
                                case GridCellKind.Uri:
                                    mangledOnCellEdited(cell, {
                                        ...cellValue,
                                        data: "",
                                    });
                                    break;
                                case GridCellKind.Image:
                                    mangledOnCellEdited(cell, {
                                        ...cellValue,
                                        data: [],
                                    });
                                    break;
                                case GridCellKind.Boolean:
                                    mangledOnCellEdited(cell, {
                                        ...cellValue,
                                        data: false,
                                    });
                                    break;
                                case GridCellKind.Number:
                                    mangledOnCellEdited(cell, {
                                        ...cellValue,
                                        data: undefined,
                                    });
                                    break;
                                default:
                                    assertNever(cellValue);
                            }
                        }
                    }
                } else if (
                    !event.metaKey &&
                    !event.ctrlKey &&
                    String.fromCharCode(event.keyCode).match(/(\w|\s)/g) &&
                    event.bounds !== undefined
                ) {
                    let key = String.fromCharCode(event.keyCode);
                    if (!event.shiftKey) {
                        key = key.toLowerCase();
                    }
                    reselect(event.bounds, key);
                    event.cancel();
                }

                const moved = updateSelectedCell(col, row);
                if (moved) {
                    event.cancel();
                }
            };
            dontAwait(fn());
        },
        [
            selectedRows,
            gridSelection,
            getCellsForSelection,
            updateSelectedCell,
            focus,
            onDeleteRows,
            selectedColumns,
            copyToClipboard,
            rowMarkerOffset,
            getCellContent,
            columns.length,
            rows,
            reselect,
            mangledOnCellEdited,
            adjustSelection,
            setGridSelection,
        ]
    );

    const onSearchResultsChanged = React.useCallback(
        (results, navIndex) => {
            if (results.length === 0 || navIndex === -1) return;

            const [col, row] = results[navIndex];
            if (lastSent.current !== undefined && lastSent.current[0] === col && lastSent.current[1] === row) {
                return;
            }
            lastSent.current = [col, row];
            updateSelectedCell(col, row);
        },
        [updateSelectedCell]
    );

    React.useEffect(() => {
        if (gridSelection === undefined) return;
        const [col, row] = gridSelection.cell;
        updateSelectedCell(col, row);
    }, [mangledCols, rows, gridSelection, updateSelectedCell]);

    const theme = useTheme();
    const mergedTheme = React.useMemo(() => {
        return { ...getBuilderTheme(), ...theme };
    }, [theme]);
    return (
        <ThemeProvider theme={mergedTheme}>
            <DataGridSearch
                {...rest}
                canvasRef={canvasRef}
                cellXOffset={(cellXOffset ? cellXOffset: visibileRegion.x) + rowMarkerOffset}
                cellYOffset={cellYOffset ? cellYOffset: visibileRegion.y}
                translateX={visibileRegion.tx}
                translateY={visibileRegion.ty}
                columns={mangledCols}
                rows={mangledRows}
                firstColSticky={rowMarkers}
                getCellContent={getMangedCellContent}
                headerHeight={headerHeight}
                onColumnMoved={onColumnMovedImpl}
                onDragStart={onDragStartImpl}
                onHeaderMenuClick={onHeaderMenuClickInner}
                onItemHovered={onItemHovered}
                onKeyDown={onKeyDown}
                onMouseDown={onMouseDown}
                onMouseUp={onMouseUp}
                onVisibleRegionChanged={onVisibleRegionChangedImpl}
                rowHeight={rowHeight}
                scrollRef={scrollRef}
                selectedCell={gridSelection}
                selectedColumns={selectedColumns}
                selectedRows={selectedRows}
                onSearchResultsChanged={onSearchResultsChanged}
                searchColOffset={rowMarkerOffset}
            />
            {overlay !== undefined && (
                <DataGridOverlayEditor
                    {...overlay}
                    imageEditorOverride={imageEditorOverride}
                    onFinishEditing={onFinishEditing}
                    markdownDivCreateNode={markdownDivCreateNode}
                />
            )}
        </ThemeProvider>
    );
};


// icons
const UpArrow = () => (
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" className="button-icon">
        <path
            fill="none"
            stroke="currentColor"
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth="48"
            d="M112 244l144-144 144 144M256 120v292"
        />
    </svg>
);
const DownArrow = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="button-icon" viewBox="0 0 512 512">
        <path
            fill="none"
            stroke="currentColor"
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth="48"
            d="M112 268l144 144 144-144M256 392V100"
        />
    </svg>
);

const CloseX = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="button-icon" viewBox="0 0 512 512">
        <path
            fill="none"
            stroke="currentColor"
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth="32"
            d="M368 368L144 144M368 144L144 368"
        />
    </svg>
);

const targetSearchTimeMS = 10;

const DataGridSearch = p => {
    const { onKeyDown, getCellsForSelection, onSearchResultsChanged, searchColOffset, ...rest } = p;
    const { canvasRef, cellYOffset, rows, columns, getCellContent } = p;

    const [searchString, setSearchString] = React.useState("");
    const [showSearch, setShowSearch] = React.useState(false);
    const [searchStatus, setSearchStatus] = React.useState();

    const searchStatusRef = React.useRef(searchStatus);
    searchStatusRef.current = searchStatus;

    const inputRef = React.useRef(null);
    const searchHandle = React.useRef();
    const [searchResults, setSearchResults] = React.useState([]);

    const cancelSearch = React.useCallback(() => {
        if (searchHandle.current !== undefined) {
            window.cancelAnimationFrame(searchHandle.current);
            searchHandle.current = undefined;
        }
    }, []);

    const getCellsForSelectionMangled = React.useCallback(
        (selection) => {
            if (getCellsForSelection !== undefined) return getCellsForSelection(selection.range);

            if (selection.range === undefined) return [[getCellContent(selection.cell)]];

            const range = selection.range;

            const result = [];
            for (let row = range.y; row < range.y + range.height; row++) {
                const inner = [];
                for (let col = range.x; col < range.x + range.width; col++) {
                    inner.push(getCellContent([col + searchColOffset, row]));
                }

                result.push(inner);
            }

            return result;
        },
        [getCellContent, getCellsForSelection, searchColOffset]
    );

    const beginSearch = React.useCallback(
        (str) => {
            const regex = new RegExp(str.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1"), "i");

            let startY = cellYOffset;

            // Vamos supor que podemos fazer 10 linhas por vez
            // Isso geralmente é muito seguro e limita os danos para o mal
            // desempenho.
            let searchStride = Math.min(10, rows);

            let rowsSearched = 0;

            setSearchStatus(undefined);
            setSearchResults([]);

            const runningResult = [];

            const tick = () => {
                const tStart = performance.now();
                const rowsLeft = rows - rowsSearched;
                const data = getCellsForSelectionMangled({
                    cell: [0, 0],
                    range: {
                        x: 0,
                        y: startY,
                        width: columns.length - searchColOffset,
                        height: Math.min(searchStride, rowsLeft, rows - startY),
                    },
                });

                let added = false;
                data.forEach((d, row) =>
                    d.forEach((cell, col) => {
                        let testString;
                        switch (cell.kind) {
                            case GridCellKind.Text:
                            case GridCellKind.Number:
                                testString = cell.displayData;
                                break;
                            case GridCellKind.Uri:
                            case GridCellKind.Markdown:
                                testString = cell.data;
                                break;
                            case GridCellKind.Boolean:
                                testString = cell.data.toString();
                                break;
                            case GridCellKind.Image:
                            case GridCellKind.Bubble:
                                // Eu sei que é preguiçoso, mas a menos que alguém esteja realmente
                                // procurando o emoji de baleia, esse é um lindo efeito colateral
                                // gratuitamente. E você sabe ... é bom e fácil de fazer ...
                                testString = cell.data.join("🐳");
                                break;
                        }

                        if (testString !== undefined && regex.test(testString)) {
                            runningResult.push([col + searchColOffset, row + startY]);
                            added = true;
                        }
                    })
                );
                const tEnd = performance.now();

                if (added) {
                    setSearchResults([...runningResult]);
                }

                rowsSearched += data.length;
                assert(rowsSearched <= rows);

                const selectedIndex = searchStatusRef.currentselectedIndex ? searchStatusRef.currentselectedIndex: -1;
                setSearchStatus({
                    results: runningResult.length,
                    rowsSearched,
                    selectedIndex,
                });
                onSearchResultsChanged(runningResult, selectedIndex);

                if (startY + searchStride >= rows) {
                    startY = 0;
                } else {
                    startY += searchStride;
                }

                const tElapsed = tEnd - tStart;
                const rounded = Math.max(tElapsed, 1);

                const scalar = targetSearchTimeMS / rounded;
                searchStride = Math.ceil(searchStride * scalar);

                if (rowsSearched < rows) {
                    searchHandle.current = window.requestAnimationFrame(tick);
                }
            };

            cancelSearch();
            searchHandle.current = window.requestAnimationFrame(tick);
        },
        [
            cancelSearch,
            cellYOffset,
            columns.length,
            getCellsForSelectionMangled,
            onSearchResultsChanged,
            rows,
            searchColOffset,
        ]
    );

    const cancelEvent = React.useCallback((ev) => {
        ev.stopPropagation();
    }, []);

    const onKeyDownImpl = React.useCallback(
        (event) => {
            if ((event.ctrlKey || event.metaKey) && event.key === "f") {
                if (!showSearch) {
                    setShowSearch(true);
                    setSearchString("");
                }
                setTimeout(() => inputRef.currentfocus(), 150);
                event.cancel();
            } else {
                onKeyDown(event);
            }
        },
        [onKeyDown, showSearch]
    );

    useEventListener(
        "keydown",
        React.useCallback(
            event => {
                if ((event.ctrlKey || event.metaKey) && event.key === "f") {
                    if (!showSearch) {
                        setShowSearch(true);
                        setSearchString("");
                    }
                    setTimeout(() => inputRef.currentfocus(), 150);
                    event.stopPropagation();
                    event.preventDefault();
                }
            },
            [showSearch]
        ),
        window,
        false,
        true
    );

    const onClose = React.useCallback(() => {
        setShowSearch(false);
        setSearchStatus(undefined);
        setSearchResults([]);
        onSearchResultsChanged([], -1);
        cancelSearch();
        canvasRefcurrentfocus();
    }, [cancelSearch, canvasRef, onSearchResultsChanged]);

    const onSearchChange = React.useCallback(
        (event) => {
            setSearchString(event.target.value);
            if (event.target.value === "") {
                setSearchStatus(undefined);
                setSearchResults([]);
                cancelSearch();
            } else {
                beginSearch(event.target.value);
            }
        },
        [beginSearch, cancelSearch]
    );

    const onNext = React.useCallback(
        (ev) => {
            evstopPropagation();
            if (searchStatus === undefined) return;
            const newIndex = (searchStatus.selectedIndex + 1) % searchStatus.results;
            setSearchStatus({
                ...searchStatus,
                selectedIndex: newIndex,
            });
            onSearchResultsChanged(searchResults, newIndex);
        },
        [searchStatus, onSearchResultsChanged, searchResults]
    );

    const onPrev = React.useCallback(
        (ev) => {
            evstopPropagation();
            if (searchStatus === undefined) return;
            let newIndex = (searchStatus.selectedIndex - 1) % searchStatus.results;
            if (newIndex < 0) newIndex += searchStatus.results;
            setSearchStatus({
                ...searchStatus,
                selectedIndex: newIndex,
            });
            onSearchResultsChanged(searchResults, newIndex);
        },
        [onSearchResultsChanged, searchResults, searchStatus]
    );

    const onSearchKeyDown = React.useCallback(
        (event) => {
            if (((event.ctrlKey || event.metaKey) && event.key === "f") || event.key === "Escape") {
                onClose();
                event.stopPropagation();
                event.preventDefault();
            } else if (event.key === "Enter") {
                if (event.shiftKey) {
                    onPrev();
                } else {
                    onNext();
                }
            }
        },
        [onClose, onNext, onPrev]
    );

    const rowsSearchedProgress = Math.floor(((searchStatusrowsSearched ? searchStatusrowsSearched: 0) / rows) * 100);
    const progressStyle = React.useMemo(() => {
        return {
            width: `${rowsSearchedProgress}%`,
        };
    }, [rowsSearchedProgress]);

    // cancel search if the component is unmounted
    React.useEffect(() => {
        return () => {
            cancelSearch();
        };
    }, [cancelSearch]);

    let resultString;
    if (searchStatus !== undefined) {
        resultString = `${searchStatus.results} result${searchStatus.results !== 1 ? "s" : ""}`;
        if (searchStatus.selectedIndex >= 0) {
            resultString = `${searchStatus.selectedIndex + 1} / ${resultString}`;
        }
    }

    return (
        <>
            <ScrollingDataGrid {...rest} onKeyDown={onKeyDownImpl} prelightCells={searchResults} />
            <SearchWrapper
                showSearch={showSearch}
                onMouseDown={cancelEvent}
                onMouseMove={cancelEvent}
                onMouseUp={cancelEvent}
                onClick={cancelEvent}>
                <div className="search-bar-inner">
                    <input
                        ref={inputRef}
                        onChange={onSearchChange}
                        value={searchString}
                        onKeyDownCapture={onSearchKeyDown}
                    />
                    <button onClick={onPrev} disabled={(searchStatusresults ? searchStatusresults: 0) === 0}>
                        <UpArrow />
                    </button>
                    <button onClick={onNext} disabled={(searchStatusresults ? searchStatusresults: 0) === 0}>
                        <DownArrow />
                    </button>
                    <button onClick={onClose}>
                        <CloseX />
                    </button>
                </div>
                {searchStatus !== undefined && (
                    <>
                        <div className="search-status">
                            <div>{resultString}</div>
                        </div>
                        <div className="search-progress" style={progressStyle} />
                    </>
                )}
            </SearchWrapper>
        </>
    );
};



const GridScroller = p => {
    const { columns, rows, rowHeight, headerHeight, firstColSticky } = p;
    const { className, onVisibleRegionChanged, scrollToEnd, scrollRef, ...dateGridProps } = p;
    const { smoothScrollX, smoothScrollY } = p;

    const [clientWidth, setClientWidth] = React.useState(10);
    const [clientHeight, setClientHeight] = React.useState(10);
    const last = React.useRef();
    const lastX = React.useRef();
    const lastY = React.useRef();

    let width = 0;
    columns.forEach(c => (width += c.width));

    let height = headerHeight;
    if (typeof rowHeight === "number") {
        height += rows * rowHeight;
    } else {
        for (let r = 0; r < rows; r++) {
            height += rowHeight(r);
        }
    }

    const onScrollUpdate = React.useCallback(
        (args) => {
            setClientHeight(args.clientHeight);
            setClientWidth(args.clientWidth);

            let x = 0;
            let tx = 0;
            let cellRight = 0;
            let cellX = 0;

            const stickyColWidth = firstColSticky ? columns[0].width : 0;

            for (const c of columns) {
                const cx = x - stickyColWidth;
                if (args.scrollLeft >= cx + c.width) {
                    x += c.width;
                    cellX++;
                    cellRight++;
                } else if (args.scrollLeft > cx) {
                    x += c.width;
                    if (smoothScrollX) {
                        tx += cx - args.scrollLeft;
                    } else {
                        cellX++;
                    }
                    cellRight++;
                } else if (args.scrollLeft + args.clientWidth > cx) {
                    x += c.width;
                    cellRight++;
                } else {
                    break;
                }
            }

            let ty = 0;
            let cellY = 0;
            let cellBottom = 0;
            if (typeof rowHeight === "number") {
                if (smoothScrollY) {
                    cellY = Math.floor(args.scrollTop / rowHeight);
                    ty = cellY * rowHeight - args.scrollTop;
                } else {
                    cellY = Math.ceil(args.scrollTop / rowHeight);
                }
                cellBottom = Math.ceil(args.clientHeight / rowHeight) + cellY;
                if (ty < 0) cellBottom++;
            } else {
                let y = 0;
                for (let row = 0; row < rows; row++) {
                    const rh = rowHeight(row);
                    const cy = y + (smoothScrollY ? 0 : rh / 2);
                    if (args.scrollTop >= y + rh) {
                        y += rh;
                        cellY++;
                        cellBottom++;
                    } else if (args.scrollTop > cy) {
                        y += rh;
                        if (smoothScrollY) {
                            ty += cy - args.scrollTop;
                        } else {
                            cellY++;
                        }
                        cellBottom++;
                    } else if (args.scrollTop + args.clientHeight > rh / 2 + y) {
                        y += rh;
                        cellBottom++;
                    } else {
                        break;
                    }
                }
            }

            const rect = {
                x: cellX,
                y: cellY,
                width: cellRight - cellX,
                height: cellBottom - cellY,
            };

            const oldRect = last.current;

            if (
                oldRect === undefined ||
                oldRect.y !== rect.y ||
                oldRect.x !== rect.x ||
                oldRect.height !== rect.height ||
                oldRect.width !== rect.width ||
                lastX.current !== tx ||
                lastY.current !== ty
            ) {
                onVisibleRegionChanged(
                    {
                        x: cellX,
                        y: cellY,
                        width: cellRight - cellX,
                        height: cellBottom - cellY,
                    },
                    tx,
                    ty
                );
                last.current = rect;
                lastX.current = tx;
                lastY.current = ty;
            }
        },
        [columns, rowHeight, rows, onVisibleRegionChanged, firstColSticky, smoothScrollX, smoothScrollY]
    );

    return (
        <ScrollRegion
            scrollRef={scrollRef}
            className={className}
            scrollWidth={width}
            scrollHeight={height}
            update={onScrollUpdate}
            scrollToEnd={scrollToEnd}>
            <DataGridDnd eventTargetRef={scrollRef} width={clientWidth} height={clientHeight} {...dateGridProps} />
        </ScrollRegion>
    );
};


const DataGridOverlayEditor = p => {
    const { target, content, onFinishEditing, forceEditMode, imageEditorOverride, markdownDivCreateNode } = p;

    const [tempValue, setTempValue] = React.useState(forceEditMode ? content : undefined);

    const onStringValueChange = React.useCallback(
        (ev) => {
            if (content.kind === GridCellKind.Text || content.kind === GridCellKind.Markdown || content.kind === GridCellKind.Uri) {
                setTempValue({
                    ...content,
                    data: ev.target.value,
                });
            }
        },
        [content]
    );

    const onImageValueChange = React.useCallback(
        (newValue) => {
            if (content.kind === GridCellKind.Image) {
                onFinishEditing(
                    {
                        ...content,
                        data: [newValue],
                    },
                    [0, 0]
                );
            }
        },
        [content, onFinishEditing]
    );
    const onNumberValueChange = React.useCallback(
        (values) => {
            if (content.kind === GridCellKind.Number) {
                setTempValue({
                    ...content,
                    data: values.floatValue,
                });
            }
        },
        [content]
    );

    const onClickOutside = React.useCallback(() => {
        onFinishEditing(tempValue, [0, 0]);
    }, [tempValue, onFinishEditing]);

    const onKeyDown = React.useCallback(
        (event) => {
            if (event.key === "Escape") {
                onFinishEditing(undefined, [0, 0]);
            } else if (event.key === "Enter" && !event.ctrlKey) {
                onFinishEditing(tempValue, [0, event.shiftKey ? -1 : 1]);
                event.stopPropagation();
                event.preventDefault();
            } else if (event.key === "Tab") {
                onFinishEditing(tempValue, [event.shiftKey ? -1 : 1, 0]);
                event.stopPropagation();
                event.preventDefault();
            }
        },
        [onFinishEditing, tempValue]
    );

    const ImageEditor = imageEditorOverride ? imageEditorOverride: ImageOverlayEditor;

    const targetValue = tempValue ? tempValue: content;
    let editor;
    switch (targetValue.kind) {
        case GridCellKind.Text:
            editor = (
                <GrowingEntry
                    autoFocus={true}
                    allowCtrlEnter={true}
                    onKeyDown={onKeyDown}
                    value={targetValue.data}
                    onChange={onStringValueChange}
                />
            );
            break;
        case GridCellKind.Uri:
            editor = (
                <UriOverlayEditor
                    forceEditMode={forceEditMode}
                    uri={targetValue.data}
                    onKeyDown={onKeyDown}
                    onChange={onStringValueChange}
                />
            );
            break;
        case GridCellKind.Boolean:
            break;
        case GridCellKind.Number:
            editor = (
                <NumberOverlayEditor value={targetValue.data} onKeyDown={onKeyDown} onChange={onNumberValueChange} />
            );
            break;
        case GridCellKind.Image:
            editor = (
                <ImageEditor
                    urls={targetValue.data}
                    canWrite={targetValue.allowAdd}
                    onCancel={onClickOutside}
                    onChange={onImageValueChange}
                    onKeyDown={onKeyDown}
                />
            );
            break;
        case GridCellKind.Bubble:
            editor = <BubblesOverlayEditor bubbles={targetValue.data} onKeyDown={onKeyDown} />;
            break;
        case GridCellKind.Markdown:
            editor = (
                <MarkdownOverlayEditor
                    markdown={targetValue.data}
                    onKeyDown={onKeyDown}
                    onChange={onStringValueChange}
                    forceEditMode={forceEditMode}
                    createNode={markdownDivCreateNode}
                />
            );
            break;
    }

    const f = (ev) => {
        ev.stopPropagation();
    };

    const portalElement = document.getElementById("portal");
    if (portalElement === null) {
        console.error(
            'Não é possível abrir o editor de sobreposição da grid de dados, porque o portal não foi encontrado. Por favor adicione `<div id="portal" />` como o último filho do seu `<body>`.'
        );
        return null;
    }
    const portal = createPortal(
        <ClickOutsideContainer onClickOutside={onClickOutside}>
            <DataGridOverlayEditorStyle targetRect={target} onMouseDown={f} onClick={f}>
                {editor}
            </DataGridOverlayEditorStyle>
        </ClickOutsideContainer>,
        portalElement
    );

    return portal;
};



class ClickOutsideContainer extends React.PureComponent {
    wrapperRef = React.createRef();

    componentDidMount() {
        document.addEventListener(this.props.stopPropagation === true ? "click" : "mousedown", this.clickOutside, true);
        document.addEventListener("contextmenu", this.clickOutside, true);
    }

    componentWillUnmount() {
        document.removeEventListener(this.props.stopPropagation === true ? "click" : "mousedown", this.clickOutside);
        document.removeEventListener("contextmenu", this.clickOutside);
    }

    clickOutside = (event) => {
        if (this.wrapperRef.current !== null && !this.wrapperRef.current.contains(event.target)) {
            let node = event.target;
            while (node !== null) {
                if (node.classList.contains("click-outside-ignore")) {
                    return;
                }

                node = node.parentElement;
            }
            if (this.props.stopPropagation === true) {
                event.stopPropagation();
                event.preventDefault();
            }
            this.props.onClickOutside();
        }
    };

    render() {
        const { onClickOutside, stopPropagation, ...rest } = this.props;
        return (
            <div {...rest} ref={this.wrapperRef}>
                {this.props.children}
            </div>
        );
    }
}




const GrowingEntryImpl = (props) => {
    const { placeholder, value, ref, onKeyDown, allowCtrlEnter, ...rest } = props;
    const { onChange, className } = rest;

    const inputRef = React.useRef(null);

    const useText = withDefault(value, "");

    assert(onChange !== undefined, "GrowingEntry must be a controlled input area");

    React.useEffect(() => {
        const ta = inputRef.current;
        if (ta === null) return;

        const length = useText.toString().length;
        ta.focus();
        ta.setSelectionRange(length, length);
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);

    const onKeyDownImpl = React.useCallback(
        (event) => {
            if (event.ctrlKey && event.key === "Enter" && allowCtrlEnter === true && inputRef.current !== null) {
                const newValue = inputRef.current.value + `\n`;
                const nativeInputValueSetter = Object.getOwnPropertyDescriptor(
                    window.HTMLTextAreaElement.prototype,
                    "value"
                );
                nativeInputValueSetter.call(inputRef.current, newValue);

                inputRef.current.dispatchEvent(new Event("change", { bubbles: true }));
            }
            onKeyDown(event);
        },
        [onKeyDown, allowCtrlEnter]
    );

    return (
        <GrowingEntryStyle>
            <ShadowBox className={className}>{useText + "\n"}</ShadowBox>
            <InputBox
                {...rest}
                ref={inputRef}
                onKeyDown={onKeyDownImpl}
                value={useText}
                placeholder={placeholder}
                dir="auto"
            />
        </GrowingEntryStyle>
    );
};

const GrowingEntry = React.memo(GrowingEntryImpl);



const inputProps = css`
    font-size: 13px;
    line-height: 16px;
    font-family: Roboto, sans-serif;
    color: ${p => p.theme.fgColorDark};
    padding: 0;
    margin: 0;
`;

export const InputBox = styled.textarea`
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;

    border-radius: 0px;

    resize: none;
    white-space: normal;
    width: 100%;
    overflow: hidden;
    border: 0;
    background-color: transparent;

    ::placeholder {
        color: ${p => p.theme.fgColorLight};
    }

    ${inputProps}
`;

const ShadowBox = styled.div`
    visibility: hidden;
    white-space: pre-wrap;
    word-wrap: break-word;
    overflow-wrap: break-word;

    width: 100%;

    ${inputProps}
`;

const GrowingEntryStyle = styled.div`
    position: relative;
    margin-top: 5px;

    min-width: 100%;
`;


export const BubblesOverlayEditorStyle = styled.div`
    display: flex;
    flex-wrap: wrap;

    .boe-bubble {
        display: flex;
        justify-content: center;
        align-items: center;

        border-radius: 100px;

        padding: 0 8px;
        height: 20px;

        background-color: ${p => p.theme.dataViewer.bgBubble};
        color: ${p => p.theme.fgColorDark};
        margin: 2px;
    }

    textarea {
        position: absolute;
        top: 0px;
        left: 0px;
        width: 0px;
        height: 0px;

        opacity: 0;
    }
`;

const BubblesOverlayEditor = p => {
    const { bubbles, onKeyDown } = p;
    return (
        <BubblesOverlayEditorStyle>
            {bubbles.map((b, i) => (
                <div key={i} className="boe-bubble">
                    {b}
                </div>
            ))}
            <textarea autoFocus={true} onKeyDown={onKeyDown} />
        </BubblesOverlayEditorStyle>
    );
};

const ImageOverlayEditorStyle = styled.div`
    display: flex;

    height: 100%;

    .centering-container {
        display: flex;
        justify-content: center;
        align-items: center;

        height: 100%;

        img,
        canvas {
            max-height: calc(100vh - var(--overlay-top) - 20px);
            object-fit: contain;
            user-select: none;
        }

        canvas {
            max-width: 380px;
        }
    }

    .edit-icon {
        position: absolute;
        top: 12px;
        right: 0;
        width: 48px;
        height: 48px;
        color: ${p => p.theme.acceptColor};

        cursor: pointer;

        display: flex;
        justify-content: center;
        align-items: center;

        > * {
            width: 24px;
            height: 24px;
        }
    }

    textarea {
        position: absolute;
        top: 0px;
        left: 0px;
        width: 0px;
        height: 0px;

        opacity: 0;
    }
`;

const ImageOverlayEditor = p => {
    const { urls, canWrite, onKeyDown, onEditClick, renderImage } = p;

    const filtered = urls.filter(u => u !== "");

    if (filtered.length === 0) {
        return null;
    }

    const allowMove = filtered.length > 1;
    return (
        <ImageOverlayEditorStyle onKeyDown={onKeyDown}>
            <Carousel
                showArrows={allowMove}
                showThumbs={false}
                swipeable={allowMove}
                emulateTouch={allowMove}
                infiniteLoop={allowMove}>
                {filtered.map(url => {
                    const innerContent = renderImage(url) ? renderImage(url): <img draggable={false} src={url} />;
                    return (
                        <div className="centering-container" key={url}>
                            {innerContent}
                        </div>
                    );
                })}
            </Carousel>
            {canWrite && onEditClick && (
                <button className="edit-icon" onClick={onEditClick}>
                    <EditPencil />
                </button>
            )}
            <textarea autoFocus={true} onKeyDown={onKeyDown} />
        </ImageOverlayEditorStyle>
    );
};

const MarkdownOverlayEditorStyle = styled.div`
    display: flex;

    position: relative;

    .edit-icon {
        position: absolute;
        top: -4px;
        right: -4px;
        width: 40px;
        height: 40px;
        color: ${p => p.theme.acceptColor};

        cursor: pointer;

        display: flex;
        justify-content: center;
        align-items: center;

        > * {
            width: 24px;
            height: 24px;
        }
    }

    textarea {
        position: absolute;
        top: 0px;
        left: 0px;
        width: 0px;
        height: 0px;

        opacity: 0;
    }
`;

const MarkdownOverlayEditor = p => {
    const { markdown, onChange, onKeyDown, forceEditMode, createNode } = p;

    const [editMode, setEditMode] = React.useState(markdown === "" || forceEditMode);

    const onEditClick = React.useCallback(() => {
        setEditMode(true);
    }, []);

    if (editMode) {
        return <GrowingEntry autoFocus={true} onKeyDown={onKeyDown} value={markdown} onChange={onChange} />;
    }

    return (
        <MarkdownOverlayEditorStyle>
            <MarkdownDiv contents={markdown} createNode={createNode} />
            <div className="edit-icon" onClick={onEditClick}>
                <EditPencil />
            </div>
            <textarea autoFocus={true} onKeyDown={onKeyDown} />
        </MarkdownOverlayEditorStyle>
    );
};

const NumberOverlayEditorStyle = styled.div`
    display: flex;
`;


function getDecimalSeparator() {
    const numberWithDecimalSeparator = 1.1;
    const result = Intl.NumberFormat()
        formatToParts(numberWithDecimalSeparator)
        find(part => part.type === "decimal");

    return result ? result : ".";
}

function getThousandSeprator() {
    return getDecimalSeparator() === "." ? "," : ".";
}

const NumberOverlayEditor = p => {
    const { value, onChange, onKeyDown } = p;
    return (
        <NumberOverlayEditorStyle>
            <NumberFormat
                autoFocus={true}
                thousandSeparator={getThousandSeprator()}
                decimalSeparator={getDecimalSeparator()}
                value={value ? value:  ""}
                // decimalScale={3}
                // prefix={"$"}
                onValueChange={onChange}
                onKeyDown={onKeyDown}
            />
        </NumberOverlayEditorStyle>
    );
};

export const UriOverlayEditorStyle = styled.div`
    display: flex;

    flex-grow: 1;

    align-items: center;

    .link-area {
        flex-grow: 1;
        flex-shrink: 1;

        display: grid;

        margin-right: 8px;
    }

    a {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;

        color: ${p => p.theme.linkColor};
        text-decoration: underline !important;
    }

    .edit-icon {
        flex-shrink: 0;
        width: 32px;
        color: ${p => p.theme.acceptColor};

        cursor: pointer;

        display: flex;
        justify-content: center;
        align-items: center;

        > * {
            width: 24px;
            height: 24px;
        }
    }

    textarea {
        position: absolute;
        top: 0px;
        left: 0px;
        width: 0px;
        height: 0px;

        opacity: 0;
    }
`;


const UriOverlayEditor = p => {
    const { uri, onChange, onKeyDown, forceEditMode } = p;

    const [editMode, setEditMode] = React.useState(uri === "" || forceEditMode);

    const onEditClick = React.useCallback(() => {
        setEditMode(true);
    }, []);

    if (editMode) {
        return <GrowingEntry autoFocus={true} onKeyDown={onKeyDown} value={uri} onChange={onChange} />;
    }

    return (
        <UriOverlayEditorStyle>
            <div className="link-area">
                <a href={uri} target="_blank" rel="noopener noreferrer">
                    {uri}
                </a>
            </div>
            <div className="edit-icon" onClick={onEditClick}>
                <EditPencil />
            </div>
            <textarea autoFocus={true} onKeyDown={onKeyDown} />
        </UriOverlayEditorStyle>
    );
};

const DataGridDnd = p => {
    const [resizeColStartX, setResizeColStartX] = React.useState();
    const [resizeCol, setResizeCol] = React.useState();
    const [dragCol, setDragCol] = React.useState();
    const [dropCol, setDropCol] = React.useState();

    const {
        firstColSticky,
        onColumnMoved,
        onMouseDown,
        onMouseUp,
        onItemHovered,
        isDraggable,
        columns,
        onColumnResized,
    } = p;

    const onItemHoveredImpl = React.useCallback(
        (args) => {
            const [col] = args.location;
            if (dragCol !== undefined && dropCol !== col && (!firstColSticky || col > 0)) {
                setDropCol(col);
            }
            onItemHovered(args);
        },
        [dragCol, dropCol, firstColSticky, onItemHovered]
    );

    const onMouseDownImpl = React.useCallback(
        (args) => {
            let shouldFireEvent = true;
            const [col] = args.location;
            if (
                (isDraggable !== true) &&
                (args.kind === "header" || args.kind === "cell") &&
                (!firstColSticky || col > 0)
            ) {
                if (args.isEdge) {
                    shouldFireEvent = false;
                    setResizeColStartX(args.bounds.x);
                    setResizeCol(col);
                } else if (args.kind === "header") {
                    setDragCol(col);
                }
            }
            if (shouldFireEvent) onMouseDown(args);
        },
        [firstColSticky, isDraggable, onMouseDown]
    );

    const onMouseUpImpl = React.useCallback(
        (args) => {
            setDragCol(undefined);
            setDropCol(undefined);
            setResizeCol(undefined);
            setResizeColStartX(undefined);
            if (dragCol !== undefined && dropCol !== undefined) {
                if (dropCol !== undefined) {
                    onColumnMoved(dragCol, dropCol);
                }
            }
            onMouseUp(args);
        },
        [dragCol, dropCol, onColumnMoved, onMouseUp]
    );

    const dragOffset = React.useMemo(() => {
        if (dragCol === undefined || dropCol === undefined) return undefined;
        if (dragCol === dropCol) return undefined;

        return {
            src: dragCol,
            dest: dropCol,
        };
    }, [dragCol, dropCol]);

    const onMouseMove = React.useCallback(
        (event) => {
            if (resizeCol === undefined || resizeColStartX === undefined) return;
            const column = columns[resizeCol];
            const newWidth = clamp(event.clientX - resizeColStartX, 50, 500);
            onColumnResized(column, newWidth);
        },
        [resizeCol, resizeColStartX, columns, onColumnResized]
    );

    return (
        <DataGrid
            {...p}
            onItemHovered={onItemHoveredImpl}
            onMouseDown={onMouseDownImpl}
            onMouseUp={onMouseUpImpl}
            dragAndDropState={dragOffset}
            onMouseMove={onMouseMove}
        />
    );
};

class ImageWindowLoader {
    imageLoaded = () => undefined;
    loadedLocations= [];

    window = {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
    };

    isInWindow(col, row) {
        const w = this.window;
        return col >= w.x && col <= w.x + w.width && row >= w.y && row <= w.y + w.height;
    }

    cache = {};

    setCallback(imageLoaded) {
        this.imageLoaded = imageLoaded;
    }

    sendLoaded = throttle(() => {
        this.imageLoaded(this.loadedLocations);
        this.loadedLocations = [];
    }, 20);

    clearOutOfWindow = debounce(() => {
        const old = this.cache;
        this.cache = {};
        Object.values(old)
            .filter(v => this.isInWindow(v.col, v.row))
            .forEach(v => {
                this.cache[`${v.url}`] = v;
            });
    }, 600);

    setWindow(window) {
        if (
            this.window.x === window.x &&
            this.window.y === window.y &&
            this.window.width === window.width &&
            this.window.height === window.height
        )
            return;
        this.window = window;
        this.clearOutOfWindow();
    }

    loadOrGetImage(url, col, row) {
        const key = `${url}`;

        const current = this.cache[key];
        if (current !== undefined) {
            current.col = col;
            current.row = row;
            return current.img;
        } else {
            const img = new Image();
            img.src = url;

            const result = {
                img: undefined,
                col,
                row,
                url,
            };

            const load = async () => {
                let errored = false;
                try {
                    await img.decode();
                } catch {
                    errored = true;
                }
                if (this.cache[key] !== undefined && !errored) {
                    result.img = img;
                    this.loadedLocations.push([col, row]);
                    this.sendLoaded();
                }
            };

            dontAwait(load());
            this.cache[key] = result;
            return undefined;
        }
    }
}

function lazilyLoadedComponent(
    _assetName,
    loader
) {
    return React.lazy(async () => await loader());
}

const AnterosAdvancedTableContainer = p => {
    const { width, height, children, ...rest } = p;
    return (
        <Wrapper width={width} height={height} {...rest}>
            {children}
        </Wrapper>
    );
};

let lastTheme;

export async function buildSpriteMap(theme) {
    // spriteCanvas = new OffscreenCanvas(spriteList.length * renderSize, 4 * renderSize);
    const themeExtract = {
        bgColorLight: theme.bgColorLight,
        fgColorDark: theme.fgColorDark,
        acceptColor: theme.acceptColor,
        columnHeaderBg: theme.dataViewer.columnHeader.bgColor,
    };
    if (
        lastTheme.acceptColor === themeExtract.acceptColor &&
        lastTheme.bgColorLight === themeExtract.bgColorLight &&
        lastTheme.columnHeaderBg === themeExtract.columnHeaderBg &&
        lastTheme.fgColorDark === themeExtract.fgColorDark
    ) {
        return;
    }

    lastTheme = themeExtract;

    let spriteCanvas = document.createElement("canvas");
    spriteCanvas.width = spriteList.length * renderSize;
    spriteCanvas.height = 4 * renderSize;
    const ctx = spriteCanvas.getContext("2d");
    if (ctx === null) return;

    let x = 0;
    for (const key of spriteList) {
        const sprite = sprites[key];

        let y = 0;
        for (const variant of variantList) {
            let fgColor = themeExtract.bgColorLight;
            let bgColor = themeExtract.fgColorDark;
            if (variant === "selected") {
                bgColor = "white";
                fgColor = themeExtract.acceptColor;
            } else if (variant === "special") {
                bgColor = themeExtract.acceptColor;
                fgColor = themeExtract.columnHeaderBg;
            }
            const renderTarget = document.createElement("canvas");
            renderTarget.width = renderSize;
            renderTarget.height = renderSize;
            const renderCtx = renderTarget.getContext("2d");
            if (renderCtx === null) continue;
            const v = Canvg.fromString(renderCtx, sprite({ fgColor, bgColor }), {
                scaleHeight: 40,
                scaleWidth: 40,
                ignoreDimensions: true,
            });
            await v.render();

            ctx.drawImage(renderTarget, x, y);

            y += renderSize;
        }

        x += renderSize;
    }
}

function drawSprite(
    sprite,
    variant,
    ctx,
    x,
    y,
    size
) {
    if (spriteCanvas === undefined) throw new Error();

    const xOffset = spriteList.indexOf(sprite) * renderSize;
    const yOffset = variantList.indexOf(variant) * renderSize;

    ctx.drawImage(spriteCanvas, xOffset, yOffset, renderSize, renderSize, x, y, size, size);
}


const AdvancedTable = p => {
    const {
        width,
        height,
        className,
        theme,
        columns,
        cellXOffset,
        cellYOffset,
        headerHeight,
        rowHeight,
        rows,
        getCellContent,
        onHeaderMenuClick,
        selectedRows,
        selectedCell,
        selectedColumns,
        firstColSticky,
        onMouseDown,
        onMouseUp,
        onMouseMove,
        onItemHovered,
        dragAndDropState,
        onKeyDown,
        onKeyUp,
        canvasRef,
        onDragStart,
        eventTargetRef,
        isDraggable,
        allowResize,
        prelightCells,
        drawCustomCell,
    } = p;
    const translateX = p.translateX ? p.translateX: 0;
    const translateY = p.translateY ? p.translateY: 0;

    const ref = React.useRef(null);
    const imageLoader = React.useRef();
    const canBlit = React.useRef();
    const damageRegion = React.useRef(undefined);
    const lastBlitData = React.useRef({ cellXOffset, cellYOffset, translateX, translateY });
    const [hoveredItem, setHoveredItem] = React.useState();
    const [hoveredOnEdge, setHoveredOnEdge] = React.useState();

    React.useEffect(() => {
        dontAwait(buildSpriteMap(theme));
    }, [theme]);

    const getBoundsForItem = React.useCallback(
        (canvas, col, row) => {
            const rect = canvas.getBoundingClientRect();

            const result = {
                x: rect.x,
                y: rect.y + headerHeight + translateY,
                width: 0,
                height: 0,
            };
            const effectiveCols = getEffectiveColumns(
                columns,
                cellXOffset,
                width,
                firstColSticky,
                undefined,
                translateX
            );

            for (const c of effectiveCols) {
                result.width = c.width + 1;
                if (c.sourceIndex === col) {
                    if (!c.sticky) result.x += translateX;
                    break;
                }
                result.x += c.width;
            }

            if (row === undefined) {
                result.y = rect.y;
                result.height = headerHeight;
            } else {
                for (let r = cellYOffset; r < row; r++) {
                    result.y += typeof rowHeight === "number" ? rowHeight : rowHeight(r);
                }
                result.height = (typeof rowHeight === "number" ? rowHeight : rowHeight(row)) + 1;
            }

            return result;
        },
        [cellXOffset, cellYOffset, columns, firstColSticky, headerHeight, rowHeight, width, translateX, translateY]
    );

    const getMouseArgsForPosition = React.useCallback(
        (canvas, posX, posY, ev) => {
            const rect = canvas.getBoundingClientRect();
            const x = posX - rect.left;
            const y = posY - rect.top;
            const edgeDetectionBuffer = 5;

            const effectiveCols = getEffectiveColumns(
                columns,
                cellXOffset,
                width,
                firstColSticky,
                undefined,
                translateX
            );

            // -1 === off right edge
            const col = getColumnIndexForX(x, effectiveCols, translateX);

            // -1: header or above
            // undefined: offbottom
            const row = getRowIndexForY(y, headerHeight, rows, rowHeight, cellYOffset, translateY);

            const shiftKey = evshiftKey === true;

            let result;
            if (col === -1 || y < 0 || x < 0 || row === undefined || x > width || y > height) {
                const horizontal = x > width ? -1 : x < 0 ? 1 : 0;
                const vertical = y > height ? 1 : y < 0 ? -1 : 0;

                result = {
                    kind: "out-of-bounds",
                    location: [col !== -1 ? col : x < 0 ? 0 : columns.length - 1, row ? row: rows - 1],
                    direction: [horizontal, vertical],
                    shiftKey,
                };
            } else if (row === -1) {
                let bounds = getBoundsForItem(canvas, col, undefined);
                const firstAllowed = firstColSticky ? 1 : 0;
                let isEdge =
                    bounds !== undefined &&
                    bounds.x + bounds.width - posX <= edgeDetectionBuffer &&
                    col >= firstAllowed;

                const previousCol = col - 1;
                if (posX - bounds.x <= edgeDetectionBuffer && previousCol >= firstAllowed) {
                    isEdge = true;
                    bounds = getBoundsForItem(canvas, previousCol, undefined);
                    result = {
                        kind: "header",
                        location: [previousCol, undefined],
                        bounds: bounds,
                        isEdge,
                        shiftKey,
                    };
                } else {
                    result = {
                        kind: "header",
                        location: [col, undefined],
                        bounds: bounds,
                        isEdge,
                        shiftKey,
                    };
                }
            } else {
                const bounds = getBoundsForItem(canvas, col, row);
                const isEdge = bounds !== undefined && bounds.x + bounds.width - posX < edgeDetectionBuffer;
                result = {
                    kind: "cell",
                    location: [col, row],
                    bounds: bounds,
                    isEdge,
                    shiftKey,
                };
            }
            return result;
        },
        [
            cellXOffset,
            cellYOffset,
            columns,
            firstColSticky,
            getBoundsForItem,
            headerHeight,
            height,
            rowHeight,
            rows,
            width,
            translateX,
            translateY,
        ]
    );

    function isSameItem(item, other) {
        if (item === other) return true;
        return (
            itemkind === otherkind &&
            itemlocation[0] === otherlocation[0] &&
            itemlocation[1] === otherlocation[1]
        );
    }

    let hoveredCol;
    if (hoveredItem[0] !== undefined && hoveredItem[1] === undefined) {
        hoveredCol = hoveredItem[0];
    }

    const drawCell = React.useCallback(
        (
            ctx,
            row,
            cell,
            sourceIndex,
            x,
            y,
            w,
            h,
            highlighted
        ) => {
            const drawn = drawCustomCell(ctx, cell, theme, { x, y, width: w, height: h }) === true;
            if (!drawn) {
                if (cell.kind === GridCellKind.Text || cell.kind === GridCellKind.Number) {
                    drawTextCell(ctx, theme, cell.displayData, x, y, w, h);
                } else if (cell.kind === GridCellKind.Markdown || cell.kind === GridCellKind.Uri) {
                    drawTextCell(ctx, theme, cell.data, x, y, w, h);
                } else if (cell.kind === GridCellKind.Boolean) {
                    if (cell.data || cell.showUnchecked) {
                        drawBoolean(ctx, theme, cell.data, x, y, w, h, highlighted);
                    }
                } else if (cell.kind === GridCellKind.Bubble) {
                    drawBubbles(ctx, theme, cell.data, x, y, w, h, highlighted);
                } else if (cell.kind === GridCellKind.Image && imageLoader.current !== undefined) {
                    drawImage(ctx, theme, cell.data, sourceIndex, row, x, y, w, h, imageLoader.current);
                } else if (cell.kind === GridCellKind.RowID) {
                    drawTextCell(ctx, theme, cell.data, x, y, w, h, theme.fgColorLight);
                } else if (cell.kind === GridCellKind.Protected) {
                    drawProtectedCell(ctx, theme, x, y, w, h, !highlighted);
                }
            }
        },
        [drawCustomCell, theme]
    );

    const draw = React.useCallback(() => {
        const canvas = ref.current;
        if (canvas === null) return;

        const dpr = window.devicePixelRatio ? window.devicePixelRatio: 1;

        if (canvas.width !== Math.floor(width * dpr) || canvas.height !== Math.floor(height * dpr)) {
            canvas.width = Math.floor(width * dpr);
            canvas.height = Math.floor(height * dpr);
        }

        const last = lastBlitData.current;
        if (
            canBlit.current === true &&
            cellXOffset === last.cellXOffset &&
            cellYOffset === last.cellYOffset &&
            translateX === last.translateX &&
            translateY === last.translateY
        )
            return;

        const ctx = canvas.getContext("2d", {
            alpha: false,
        });
        if (ctx === null) return;

        const getRowHeight = (r) => (typeof rowHeight === "number" ? rowHeight : rowHeight(r));

        ctx.save();
        ctx.beginPath(); // clear any path in the ctx
        if (dpr !== 1) {
            ctx.scale(dpr, dpr);
        }

        const damage = damageRegion.current;
        const drawRegions = [];
        let blittedYOnly = false;

        const effectiveCols = getEffectiveColumns(
            columns,
            cellXOffset,
            width,
            firstColSticky,
            dragAndDropState,
            translateX
        );

        if (canBlit.current === true) {
            const minY = Math.min(last.cellYOffset, cellYOffset);
            const maxY = Math.max(last.cellYOffset, cellYOffset);
            let deltaY = 0;
            for (let i = minY; i < maxY; i++) {
                deltaY += getRowHeight(i);
            }
            if (cellYOffset > last.cellYOffset) {
                deltaY = -deltaY;
            }
            deltaY += translateY - last.translateY;

            const minX = Math.min(last.cellXOffset, cellXOffset);
            const maxX = Math.max(last.cellXOffset, cellXOffset);
            let deltaX = 0;
            for (let i = minX; i < maxX; i++) {
                deltaX += columns[i].width;
            }
            if (cellXOffset > last.cellXOffset) {
                deltaX = -deltaX;
            }
            deltaX += translateX - last.translateX;

            let stickyWidth = 0;
            for (const c of effectiveCols) {
                if (c.sticky) {
                    stickyWidth += c.width + 1;
                } else {
                    break;
                }
            }
            const blitWidth = width - stickyWidth - Math.abs(deltaX);
            const blitHeight = height - headerHeight - Math.abs(deltaY) - 1;

            if (blitWidth > 150 && blitHeight > 150) {
                blittedYOnly = deltaX === 0;

                // blit Y
                if (deltaY > 0) {
                    // scrolling up
                    ctx.drawImage(
                        canvas,
                        0,
                        (headerHeight + 1) * dpr,
                        width * dpr,
                        blitHeight * dpr,
                        0,
                        deltaY + headerHeight + 1,
                        width,
                        blitHeight
                    );
                    drawRegions.push({
                        x: 0,
                        y: headerHeight,
                        width: width,
                        height: deltaY + 1,
                    });
                } else if (deltaY < 0) {
                    // scrolling down
                    ctx.drawImage(
                        canvas,
                        0,
                        (-deltaY + headerHeight + 1) * dpr,
                        width * dpr,
                        blitHeight * dpr,
                        0,
                        headerHeight + 1,
                        width,
                        blitHeight
                    );
                    drawRegions.push({
                        x: 0,
                        y: height + deltaY,
                        width: width,
                        height: -deltaY,
                    });
                }

                // blit X
                if (deltaX > 0) {
                    // scrolling right
                    ctx.drawImage(
                        canvas,
                        stickyWidth * dpr,
                        0,
                        blitWidth * dpr,
                        height * dpr,
                        deltaX + stickyWidth,
                        0,
                        blitWidth,
                        height
                    );
                    drawRegions.push({
                        x: stickyWidth - 1,
                        y: 0,
                        width: deltaX + 1,
                        height: height,
                    });
                } else if (deltaX < 0) {
                    // scrolling left
                    ctx.drawImage(
                        canvas,
                        (stickyWidth - deltaX) * dpr,
                        0,
                        blitWidth * dpr,
                        height * dpr,
                        stickyWidth,
                        0,
                        blitWidth,
                        height
                    );
                    drawRegions.push({
                        x: width + deltaX,
                        y: 0,
                        width: -deltaX,
                        height: height,
                    });
                }

                if (drawRegions.length > 0) {
                    for (const r of drawRegions) {
                        ctx.rect(r.x, r.y, r.width, r.height);
                    }
                    ctx.clip();
                    ctx.beginPath();
                }
            }
        }

        if (damage !== undefined) {
            let _row = cellYOffset;
            let y = headerHeight + translateY;
            ctx.beginPath();
            while (y < height) {
                let x = 0;
                const rh = getRowHeight(_row);

                for (const c of effectiveCols) {
                    const rowLocal = _row;
                    if (damage.find(d => d[0] === c.sourceIndex && d[1] === rowLocal) !== undefined) {
                        const tx = c.sticky ? 0 : translateX;
                        ctx.rect(x + 1 + tx, y + 1, c.width - 1, rh - 1);
                    }
                    x += c.width;
                }

                _row++;
                y += rh;
            }

            ctx.clip();
            ctx.beginPath();
        }

        ctx.fillStyle = theme.dataViewer.gridColor;
        ctx.fillRect(0, headerHeight + 1, width, height - headerHeight - 1);

        if (!blittedYOnly && damage === undefined) {
            // desenhar fundo do cabeçalho
            ctx.fillStyle = theme.dataViewer.columnHeader.bgColor;
            ctx.fillRect(0, 0, width, headerHeight);
        }

        // desenhar linhas de uma vez
        {
            ctx.beginPath();

            // linhas verticais
            let x = 0.5;
            effectiveCols.forEach(c => {
                x += c.width;
                const tx = c.sticky ? x : x + translateX;
                ctx.moveTo(tx, 0);
                ctx.lineTo(tx, height);
            });

            // linhas horizontais
            let y = headerHeight + 0.5;
            let _row = cellYOffset;
            let isHeader = true;
            while (y + translateY <= height) {
                const ty = isHeader ? y : y + translateY;
                ctx.moveTo(0, ty);
                ctx.lineTo(width, ty);

                y += getRowHeight(_row);
                isHeader = false;
                _row++;
            }

            ctx.strokeStyle = theme.borderColor;
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        const xPad = 8;
        const yPad = 2;

        // desenhar o conteúdo do cabeçalho
        if (!blittedYOnly && damage === undefined) {
            let x = 0;
            let clipX = 0;
            for (const c of effectiveCols) {
                const selected = selectedColumnsincludes(c.sourceIndex);
                const hovered = hoveredCol === c.sourceIndex && dragAndDropState === undefined;

                const hasSelectedCell = selectedCell !== undefined && selectedCell.cell[0] === c.sourceIndex;

                const fillStyle = selected
                    ? theme.dataViewer.columnHeader.fgSelected
                    : theme.dataViewer.columnHeader.fgColor;

                const bgFillStyle = selected
                    ? theme.dataViewer.columnHeader.bgSelected
                    : hasSelectedCell
                    ? theme.dataViewer.columnHeader.bgDark
                    : theme.dataViewer.columnHeader.bgColor;

                ctx.save();
                if (c.sticky) {
                    clipX = Math.max(clipX, x + c.width);
                } else {
                    ctx.beginPath();
                    ctx.rect(clipX, 0, width, height);
                    ctx.clip();
                    ctx.translate(translateX, 0);
                }

                if (selected) {
                    ctx.fillStyle = bgFillStyle;
                    ctx.fillRect(x + 1, 0, c.width - 1, headerHeight);
                } else if (hasSelectedCell) {
                    ctx.fillStyle = theme.dataViewer.columnHeader.bgDark;
                    ctx.fillRect(x + 1, 0, c.width - 1, headerHeight);
                }

                ctx.beginPath();
                ctx.rect(x + xPad, yPad, c.width - xPad, headerHeight - yPad * 2);
                ctx.clip();

                let drawX = x + xPad;
                ctx.globalAlpha = hovered || selected ? 1 : 0.6;
                if (c.icon !== undefined) {
                    let variant = selected ? "selected" : "normal";
                    if (c.style === "highlight") {
                        variant = selected ? "selected" : "special";
                    }
                    drawSprite(c.icon, variant, ctx, drawX, (headerHeight - 20) / 2, 20);

                    if (c.overlayIcon !== undefined) {
                        ctx.globalAlpha = 1;
                        drawSprite(
                            c.overlayIcon,
                            selected ? "selected" : "special",
                            ctx,
                            drawX + 9,
                            (headerHeight - 18) / 2 + 6,
                            18
                        );
                        ctx.globalAlpha = hovered || selected ? 1 : 0.6;
                    }

                    drawX += 26;
                }

                ctx.font = "bold 14px Roboto, sans-serif";
                ctx.fillStyle = fillStyle;
                ctx.fillText(c.title, drawX, headerHeight / 2 + 5);
                ctx.globalAlpha = 1;

                if (hovered && c.hasMenu === true) {
                    const fadeWidth = 35;
                    const fadeStart = x + c.width - fadeWidth;
                    const grad = ctx.createLinearGradient(fadeStart, 0, fadeStart + fadeWidth, 0);
                    grad.addColorStop(0, bgFillStyle + "00");
                    grad.addColorStop(0.3, bgFillStyle);
                    grad.addColorStop(1, bgFillStyle);
                    ctx.fillStyle = grad;
                    ctx.rect(fadeStart, 0, fadeWidth, headerHeight);
                    ctx.fill();

                    ctx.beginPath();
                    const triangleX = x + c.width - 20;
                    const triangleY = headerHeight / 2 - 3;
                    roundedPoly(
                        ctx,
                        [
                            {
                                x: triangleX,
                                y: triangleY,
                            },
                            {
                                x: triangleX + 11,
                                y: triangleY,
                            },
                            {
                                x: triangleX + 5.5,
                                y: triangleY + 6,
                            },
                        ],
                        1
                    );

                    ctx.fillStyle = fillStyle;
                    ctx.fill();
                }

                ctx.restore();

                x += c.width;
            }
        }

        ctx.beginPath();
        ctx.rect(0, headerHeight + 1, width, height - headerHeight - 1);
        ctx.clip();
        ctx.beginPath();
        // desenha o conteúdo da célula
        let row = cellYOffset;
        {
            // vamos definir a fonte aqui porque definir isso no FF é lento
            // por nenhuma razão óbvia. Ele será salvo / restaurado conforme necessário de qualquer maneira. Todas as células
            // pode depender da fonte padrão que está sendo definida e não precisa defini-la por conta própria.
            ctx.font = "13px Roboto, sans-serif";
            let y = headerHeight + translateY;
            while (y < height) {
                let x = 0;
                let clipX = 0;
                const rh = getRowHeight(row);

                if (
                    drawRegions.length === 0 ||
                    drawRegions.find(
                        drawRegion =>
                            (y >= drawRegion.y && y <= drawRegion.y + drawRegion.height) ||
                            (drawRegion.y >= y && drawRegion.y <= y + rh)
                    )
                ) {
                    const rowSelected = selectedRowsincludes(row);
                    for (const c of effectiveCols) {
                        const rowLocal = row;
                        if (
                            damage !== undefined &&
                            damage.find(d => d[0] === c.sourceIndex && d[1] === rowLocal) === undefined
                        ) {
                            x += c.width;
                            continue;
                        }

                        ctx.save();
                        ctx.beginPath();
                        if (c.sticky) {
                            clipX = Math.max(clipX, x + c.width);
                            ctx.rect(x, y, c.width, rh);
                            ctx.clip();
                        } else {
                            const diff = Math.min(0, x + translateX - clipX);
                            ctx.rect(Math.max(x + translateX, clipX), y, c.width + diff, rh);
                            ctx.clip();
                            ctx.translate(translateX, 0);
                        }
                        ctx.beginPath();

                        const isFocused = selectedCellcell[0] === c.sourceIndex && selectedCellcell[1] === row;
                        let highlighted = rowSelected || selectedColumnsincludes(c.sourceIndex) || isFocused;

                        if (selectedCellrange !== undefined) {
                            const { range } = selectedCell;
                            if (
                                c.sourceIndex >= range.x &&
                                c.sourceIndex < range.x + range.width &&
                                row >= range.y &&
                                row < range.y + range.height
                            ) {
                                highlighted = true;
                            }
                        }

                        if (highlighted) {
                            ctx.fillStyle = theme.dataViewer.bgSelected;
                            if (x === 0) {
                                ctx.fillRect(x, y + 1, c.width, rh - 1);
                            } else {
                                ctx.fillRect(x + 1, y + 1, c.width - 1, rh - 1);
                            }
                        } else {
                            // eslint-disable-next-line no-loop-func
                            if (prelightCellsfind(pre => pre[0] === c.sourceIndex && pre[1] === row) !== undefined) {
                                ctx.fillStyle = theme.dataViewer.bgPrelight;
                                if (x === 0) {
                                    ctx.fillRect(x, y + 1, c.width, rh - 1);
                                } else {
                                    ctx.fillRect(x + 1, y + 1, c.width - 1, rh - 1);
                                }
                            }
                        }

                        const cell =
                            row < rows
                                ? getCellContent([c.sourceIndex, row])
                                : {
                                      kind: GridCellKind.Loading,
                                      allowOverlay: false,
                                  };

                        if (cell.style === "faded") {
                            ctx.globalAlpha = 0.6;
                        }

                        drawCell(ctx, row, cell, c.sourceIndex, x, y, c.width, rh, highlighted);

                        ctx.globalAlpha = 1;

                        ctx.restore();

                        if (isFocused) {
                            ctx.save();
                            ctx.beginPath();
                            if (c.sticky) {
                                ctx.rect(x, y, c.width + 1, rh + 1);
                                ctx.clip();
                            } else {
                                ctx.rect(Math.max(x, clipX) + translateX, y, c.width + 1, rh + 1);
                                ctx.clip();
                                ctx.translate(translateX, 0);
                            }

                            ctx.beginPath();
                            ctx.rect(x + 1, y + 1, c.width - 1, rh - 1);
                            ctx.strokeStyle = theme.acceptColor;
                            ctx.lineWidth = 2;
                            ctx.stroke();
                            ctx.restore();
                        }

                        x += c.width;
                    }

                    if (x < width && rowSelected) {
                        ctx.beginPath();
                        ctx.fillStyle = theme.dataViewer.bgSelected;
                        ctx.fillRect(x + 1, y + 1, width - x, rh - 1);
                    }
                }

                y += rh;
                row++;
            }
        }

        imageLoader.currentsetWindow({
            x: cellXOffset,
            y: cellYOffset,
            width: effectiveCols.length,
            height: row - cellYOffset,
        });

        lastBlitData.current = { cellXOffset, cellYOffset, translateX, translateY };

        ctx.restore();
    }, [
        width,
        height,
        columns,
        cellXOffset,
        firstColSticky,
        translateX,
        translateY,
        dragAndDropState,
        theme.dataViewer.gridColor,
        theme.dataViewer.columnHeader.bgColor,
        theme.dataViewer.columnHeader.fgSelected,
        theme.dataViewer.columnHeader.fgColor,
        theme.dataViewer.columnHeader.bgSelected,
        theme.dataViewer.columnHeader.bgDark,
        theme.dataViewer.bgSelected,
        theme.dataViewer.bgPrelight,
        theme.borderColor,
        theme.acceptColor,
        cellYOffset,
        rowHeight,
        headerHeight,
        selectedColumns,
        hoveredCol,
        selectedCell,
        selectedRows,
        rows,
        getCellContent,
        drawCell,
        prelightCells,
    ]);

    React.useEffect(() => {
        imageLoader.current = new ImageWindowLoader();
    }, []);

    canBlit.current = canBlit.current !== undefined;
    React.useEffect(() => {
        canBlit.current = false;
    }, [
        width,
        height,
        columns,
        theme,
        headerHeight,
        rowHeight,
        rows,
        getCellContent,
        selectedRows,
        selectedColumns,
        selectedCell,
        firstColSticky,
        dragAndDropState,
        hoveredCol,
        prelightCells,
    ]);

    React.useEffect(draw, [draw]);

    const imageLoaded = React.useCallback(
        (locations) => {
            canBlit.current = false;
            damageRegion.current = locations;
            draw();
            damageRegion.current = undefined;
        },
        [draw]
    );

    imageLoader.currentsetCallback(imageLoaded);

    const headerHovered = hoveredItem[0] !== undefined && hoveredItem[1] === undefined;
    const canDrag = hoveredOnEdge ? hoveredOnEdge: false;
    const style = React.useMemo(
        () => ({
            width,
            height,
            display: "block",
            cursor: canDrag ? "col-resize" : headerHovered ? "pointer" : "default",
        }),
        [width, height, headerHovered, canDrag]
    );

    const target = eventTargetRefcurrent;
    if (target !== null && target !== undefined) {
        // porque temos um alvo de evento, precisamos definir seu cursor.
        target.style.cursor = style.cursor;
    }

    const onMouseDownImpl = React.useCallback(
        (ev) => {
            const canvas = ref.current;
            const eventTarget = eventTargetRefcurrent;
            if (canvas === null || (ev.target !== canvas && ev.target !== eventTarget)) return;
            const args = getMouseArgsForPosition(canvas, ev.clientX, ev.clientY, ev);

            if (args.kind === "header") {
                const [col] = args.location;
                const header = columns[col];

                if (header.hasMenu === true && !(hoveredOnEdge ? hoveredOnEdge: false)) {
                    const headerBounds = getBoundsForItem(canvas, col, undefined);
                    if (ev.clientX > headerBounds.x + headerBounds.width - 40) {
                        onHeaderMenuClick(col, headerBounds);
                        return;
                    }
                }
            }

            onMouseDown(args);
        },
        [
            eventTargetRef,
            getMouseArgsForPosition,
            onMouseDown,
            columns,
            hoveredOnEdge,
            getBoundsForItem,
            onHeaderMenuClick,
        ]
    );
    useEventListener("mousedown", onMouseDownImpl, window, true);

    const onMouseUpImpl = React.useCallback(
        (ev) => {
            const canvas = ref.current;
            if (canvas === null || onMouseUp === undefined) return;

            onMouseUp(getMouseArgsForPosition(canvas, ev.clientX, ev.clientY, ev));
        },
        [getMouseArgsForPosition, onMouseUp]
    );
    useEventListener("mouseup", onMouseUpImpl, window, true);

    const hoveredRef = React.useRef();
    const onMouseMoveImpl = React.useCallback(
        (ev) => {
            const canvas = ref.current;
            if (canvas === null) return;

            const args = getMouseArgsForPosition(canvas, ev.clientX, ev.clientY, ev);
            if (!isSameItem(args, hoveredRef.current)) {
                onItemHovered(args);
                setHoveredItem(args.kind === "out-of-bounds" ? undefined : args.location);
                hoveredRef.current = args;
            }
            if (args.kind !== "out-of-bounds") {
                setHoveredOnEdge(args.isEdge && allowResize === true);
            }

            onMouseMove(ev);
        },
        [getMouseArgsForPosition, onItemHovered, allowResize, onMouseMove]
    );
    useEventListener("mousemove", onMouseMoveImpl, window, true);

    const onKeyDownImpl = React.useCallback(
        (event) => {
            const canvas = ref.current;
            if (canvas === null) return;

            let bounds;
            if (selectedCell !== undefined) {
                bounds = getBoundsForItem(canvas, selectedCell.cell[0], selectedCell.cell[1]);
            }

            onKeyDown({
                bounds,
                cancel: () => {
                    event.stopPropagation();
                    event.preventDefault();
                },
                ctrlKey: event.ctrlKey,
                metaKey: event.metaKey,
                shiftKey: event.shiftKey,
                key: event.key,
                keyCode: event.keyCode,
            });
        },
        [onKeyDown, selectedCell, getBoundsForItem]
    );

    const onKeyUpImpl = React.useCallback(
        (event) => {
            const canvas = ref.current;
            if (canvas === null) return;

            let bounds;
            if (selectedCell !== undefined) {
                bounds = getBoundsForItem(canvas, selectedCell.cell[0], selectedCell.cell[1]);
            }

            onKeyUp({
                bounds,
                cancel: () => {
                    event.stopPropagation();
                    event.preventDefault();
                },
                ctrlKey: event.ctrlKey,
                metaKey: event.metaKey,
                shiftKey: event.shiftKey,
                key: event.key,
                keyCode: event.keyCode,
            });
        },
        [onKeyUp, selectedCell, getBoundsForItem]
    );

    const refImpl = React.useCallback(
        (instance) => {
            ref.current = instance;
            if (canvasRef !== undefined) {
                canvasRef.current = instance;
            }
        },
        [canvasRef]
    );

    const onDragStartImpl = React.useCallback(
        (event) => {
            const canvas = ref.current;
            if (canvas === null || !isDraggable === true) return;

            let dragMime;
            let dragData;

            const args = getMouseArgsForPosition(canvas, event.clientX, event.clientY);

            const setData = (mime, payload) => {
                dragMime = mime;
                dragData = payload;
            };

            let dragImage;
            let dragImageX;
            let dragImageY;
            const setDragImage = (image, x, y) => {
                dragImage = image;
                dragImageX = x;
                dragImageY = y;
            };

            onDragStart({
                ...args,
                setData,
                setDragImage,
            });
            if (dragMime !== undefined && dragData !== undefined) {
                event.dataTransfer.setData(dragMime, dragData);
                event.dataTransfer.effectAllowed = "link";

                if (dragImage !== undefined && dragImageX !== undefined && dragImageY !== undefined) {
                    event.dataTransfer.setDragImage(dragImage, dragImageX, dragImageY);
                } else {
                    const [col, row] = args.location;
                    if (row !== undefined) {
                        const offscreen = document.createElement("canvas");
                        const boundsForDragTarget = getBoundsForItem(canvas, col, row);

                        offscreen.width = boundsForDragTarget.width;
                        offscreen.height = boundsForDragTarget.height;

                        const ctx = offscreen.getContext("2d");
                        if (ctx !== null) {
                            ctx.fillStyle = theme.dataViewer.bgColor;
                            ctx.fillRect(0, 0, offscreen.width, offscreen.height);
                            drawCell(
                                ctx,
                                row,
                                getCellContent([col, row]),
                                0,
                                0,
                                0,
                                boundsForDragTarget.width,
                                boundsForDragTarget.height,
                                false
                            );
                        }

                        offscreen.style.left = "-100%";
                        offscreen.style.position = "absolute";

                        document.body.appendChild(offscreen);

                        event.dataTransfer.setDragImage(
                            offscreen,
                            boundsForDragTarget.width / 2,
                            boundsForDragTarget.height / 2
                        );

                        window.setTimeout(() => {
                            document.body.removeChild(offscreen);
                        }, 0);
                    }
                }
            } else {
                event.preventDefault();
            }
        },
        [
            isDraggable,
            getMouseArgsForPosition,
            onDragStart,
            getBoundsForItem,
            theme.dataViewer.bgColor,
            drawCell,
            getCellContent,
        ]
    );

    return (
        <canvas
            draggable={isDraggable === true}
            tabIndex={0}
            onKeyDown={onKeyDownImpl}
            onKeyUp={onKeyUpImpl}
            className={className}
            ref={refImpl}
            style={style}
            onDragStart={onDragStartImpl}
        />
    );
};

const AnterosAdvancedTable = React.memo(withTheme(AdvancedTable));

export {AnterosAdvancedTable, AnterosAdvancedTableEditor, AnterosAdvancedTableContainer, GridCellKind}
